/*
 **************************************************************************************
 *sc2233_xc7021.c
 *A V4L2 driver for sc2233_xc7021 cameras
 *Copyright (c) 2014 by Allwinnertech Co., Ltd.http://www.allwinnertech.com
 ***************************************************************************************
 */
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/i2c.h>
#include <linux/delay.h>
#include <linux/videodev2.h>
#include <linux/clk.h>
#include <media/v4l2-device.h>
#include <media/v4l2-chip-ident.h>
#include <media/v4l2-mediabus.h>
#include <linux/io.h>
#include "camera.h"

/* static struct delayed_work sensor_s_ae_ratio_work; */
#define SENSOR_NAME "sc2233_xc7021"
#include "sensor_helper.h"

MODULE_AUTHOR("zequn.zheng");
MODULE_DESCRIPTION("A low-level driver for sc2233_xc7021 sensors");
MODULE_LICENSE("GPL");

/*define module timing*/
#define MCLK              (24*1000*1000)
#define VREF_POL          V4L2_MBUS_VSYNC_ACTIVE_LOW
#define HREF_POL          V4L2_MBUS_HSYNC_ACTIVE_HIGH
#define CLK_POL           V4L2_MBUS_PCLK_SAMPLE_RISING
#define V4L2_IDENT_SENSOR  0x7021
#define sc2233_CHIPID      0x2235

/*
 * Our nominal (default) frame rate.
 */
#define SENSOR_FRAME_RATE       30
#define SENSOR_FRAME_RATE_15FPS 15

/*
 * The  ISP xc7021 i2c address
 */
#define XC7021_WRITE_ADDR   (0x36)
#define XC7021_READ_ADDR    (0x37)
/*
 * The  sc2233 sensor i2c address, the sc2233 i2c address  different XC7021 address
 */
#define I2C_ADDR_sc2233_SENSOR  (0x60 >> 1)

/*#define DEBUG_COLORBAR       1*/


static int sc2233_i2c_bypass(struct v4l2_subdev *sd, bool enable);

/*
 * Information we maintain about a known sensor.
 */

static struct regval_list bypass_on[] = {
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x004d, 0x01},
};

static struct regval_list bypass_off[] = {
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x004d, 0x00},
};


static struct regval_list XC7021_default_regs[] = { /* 1920x1080@30fps yuv422 */
	/* XC7021 setting */

	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x001c, 0xff},
	{0x001d, 0xff},
	{0x001e, 0xff},
	{0x001f, 0xff},
	{0x0018, 0x00},
	{0x0019, 0x00},
	{0x001a, 0x00},
	{0x001b, 0x00},
	{0x00bc, 0x11},
	{0x00bd, 0x00},
	{0x00be, 0x00},
	{0x00bf, 0x00},

	{0x0030, 0x09},
	{0x0031, 0x02},
	{0x0032, 0x0c},

	{0x0020, 0x01},
	{0x0021, 0x0e},
	{0x0023, 0x02},
	{0x0024, 0x06},
	{0x0025, 0x06},
	{0x0026, 0x01},
	{0x0027, 0x06},
	{0x0028, 0x08},
	{0x0029, 0x06},
	{0x00aa, 0x40},

	{0xfffe, 0x50},
	{0x0200, 0x03},
	{0x0204, 0x03},
	{0x0208, 0x00},
	{0x0208, 0x03},

	{0xfffe, 0x50},
	{0x00bc, 0x11},
	{0x001b, 0x0},
	{0x0090, 0x29},

	{0xfffe, 0x20},
	{0x0000, 0x20},
	{0x0004, 0x7},
	{0x0005, 0x80},
	{0x0006, 0x4},
	{0x0007, 0x38},

	{0xfffe, 0x26},
	{0x4000, 0xF9},
	{0x6001, 0x14},
	{0x6005, 0xc4},
	{0x6006, 0xF},
	{0x6007, 0xA0},
	{0x6008, 0xE},
	{0x6009, 0xFC},

	{0x8000, 0x3f},
	{0x8001, 0x80},
	{0x8002, 0x7},
	{0x8003, 0x38},
	{0x8004, 0x4},
	{0x8005, 0x3},
	{0x8006, 0x5},
	{0x8007, 0x99},
	{0x8008, 0x14},

	{0x8010, 0x4},
	{0x8012, 0x80},
	{0x8013, 0x7},
	{0x8014, 0x38},
	{0x8015, 0x4},
	{0x8016, 0x0},
	{0x8017, 0x0},
	{0x8018, 0x0},
	{0x8019, 0x0},

	{0xfffe, 0x30},
	{0x0001, 0x1},
	{0x0004, 0x18},
	{0x0006, 0x7},
	{0x0007, 0x80},
	{0x0008, 0x4},
	{0x0009, 0x38},
	{0x000a, 0x7},
	{0x000b, 0x80},
	{0x000c, 0x4},
	{0x000d, 0x38},
	{0x0027, 0xF7},
	{0x005e, 0x7},
	{0x005f, 0x7F},
	{0x0060, 0x4},
	{0x0061, 0x37},
	{0x1908, 0x0},
	{0x1900, 0x0},
	{0x1901, 0x0},
	{0x1902, 0x0},
	{0x1903, 0x0},
	{0x1904, 0x7},
	{0x1905, 0x80},
	{0x1906, 0x4},
	{0x1907, 0x38},

	{0xfffe, 0x25},
	{0x0002, 0x80},


	/*patch start*/
	{0xfffe, 0x50},
	{0x000e, 0x54},

	{0xfffe, 0x14},
	{0x0006, 0x00},
	{0x0007, 0x0b},
	{0x0014, 0x00},
	{0x0015, 0x14},
	{0x0016, 0x07},
	{0x0017, 0xc4},
	{0x03d4, 0x9c},
	{0x03d5, 0x21},
	{0x03d6, 0xff},
	{0x03d7, 0xe4},
	{0x03d8, 0xd4},
	{0x03d9, 0x01},
	{0x03da, 0x48},
	{0x03dc, 0xd4},
	{0x03dd, 0x01},
	{0x03de, 0x50},
	{0x03df, 0x04},
	{0x03e0, 0xd4},
	{0x03e1, 0x01},
	{0x03e2, 0x60},
	{0x03e3, 0x08},
	{0x03e4, 0xd4},
	{0x03e5, 0x01},
	{0x03e6, 0x70},
	{0x03e7, 0x0c},
	{0x03e8, 0xd4},
	{0x03e9, 0x01},
	{0x03ea, 0x80},
	{0x03eb, 0x10},
	{0x03ec, 0xd4},
	{0x03ed, 0x01},
	{0x03ee, 0x90},
	{0x03ef, 0x14},
	{0x03f0, 0xd4},
	{0x03f1, 0x01},
	{0x03f2, 0xa0},
	{0x03f3, 0x18},
	{0x03f4, 0x1a},
	{0x03f7, 0x14},
	{0x03f8, 0xaa},
	{0x03f9, 0x10},
	{0x03fa, 0x02},
	{0x03fb, 0xb0},
	{0x03fc, 0x9c},
	{0x03fd, 0x60},
	{0x03fe, 0x39},
	{0x03ff, 0x03},
	{0x0400, 0x84},
	{0x0401, 0xd0},
	{0x0404, 0x9c},
	{0x0405, 0x80},
	{0x0407, 0x84},
	{0x0408, 0x8c},
	{0x0409, 0xa6},
	{0x040b, 0x8b},
	{0x040c, 0x85},
	{0x040d, 0x86},
	{0x040f, 0xd0},
	{0x0410, 0x8d},
	{0x0411, 0xc6},
	{0x0413, 0x8e},
	{0x0414, 0x07},
	{0x0415, 0xfb},
	{0x0416, 0x1a},
	{0x0417, 0x10},
	{0x0418, 0xb9},
	{0x0419, 0x4c},
	{0x041b, 0x41},
	{0x041c, 0x84},
	{0x041d, 0x90},
	{0x0420, 0x9c},
	{0x0421, 0x60},
	{0x0422, 0x39},
	{0x0423, 0x03},
	{0x0424, 0x8c},
	{0x0425, 0xa4},
	{0x0427, 0x8b},
	{0x0428, 0x07},
	{0x0429, 0xfb},
	{0x042a, 0x1a},
	{0x042b, 0x0b},
	{0x042c, 0x9c},
	{0x042d, 0x80},
	{0x042f, 0x04},
	{0x0430, 0x84},
	{0x0431, 0x90},
	{0x0434, 0x9c},
	{0x0435, 0x60},
	{0x0436, 0x38},
	{0x0437, 0x12},
	{0x0438, 0x8c},
	{0x0439, 0xa4},
	{0x043b, 0x8b},
	{0x043c, 0x07},
	{0x043d, 0xfb},
	{0x043e, 0x1a},
	{0x043f, 0x06},
	{0x0440, 0x9c},
	{0x0441, 0x80},
	{0x0444, 0xbc},
	{0x0445, 0x2e},
	{0x0447, 0x01},
	{0x0448, 0x0c},
	{0x044b, 0x66},
	{0x044c, 0xbc},
	{0x044d, 0x4a},
	{0x044f, 0x1f},
	{0x0450, 0x10},
	{0x0453, 0x2d},
	{0x0454, 0xbc},
	{0x0455, 0x4a},
	{0x0457, 0x3f},
	{0x0458, 0x9e},
	{0x0459, 0x80},
	{0x045c, 0xa6},
	{0x045d, 0x4a},
	{0x045e, 0xff},
	{0x045f, 0xff},
	{0x0460, 0x84},
	{0x0461, 0x90},
	{0x0464, 0x9c},
	{0x0465, 0x60},
	{0x0466, 0x3e},
	{0x0467, 0x09},
	{0x0468, 0x8c},
	{0x0469, 0xa4},
	{0x046b, 0x8b},
	{0x046c, 0x07},
	{0x046d, 0xfb},
	{0x046e, 0x19},
	{0x046f, 0xfa},
	{0x0470, 0xa8},
	{0x0471, 0x92},
	{0x0474, 0x84},
	{0x0475, 0x70},
	{0x0478, 0xb8},
	{0x0479, 0x94},
	{0x047b, 0x02},
	{0x047c, 0x8c},
	{0x047d, 0xa3},
	{0x047f, 0x8b},
	{0x0480, 0x9c},
	{0x0481, 0x84},
	{0x0483, 0x03},
	{0x0484, 0x07},
	{0x0485, 0xfb},
	{0x0486, 0x19},
	{0x0487, 0xf4},
	{0x0488, 0x9c},
	{0x0489, 0x60},
	{0x048a, 0x3e},
	{0x048b, 0x08},
	{0x048c, 0xb8},
	{0x048d, 0x94},
	{0x048f, 0x46},
	{0x0490, 0x84},
	{0x0491, 0xb0},
	{0x0494, 0x9c},
	{0x0495, 0x60},
	{0x0496, 0x3e},
	{0x0497, 0x07},
	{0x0498, 0x8c},
	{0x0499, 0xa5},
	{0x049b, 0x8b},
	{0x049c, 0xa4},
	{0x049d, 0x84},
	{0x049e, 0xff},
	{0x049f, 0xff},
	{0x04a0, 0x07},
	{0x04a1, 0xfb},
	{0x04a2, 0x19},
	{0x04a3, 0xed},
	{0x04a4, 0x15},
	{0x04a8, 0xbc},
	{0x04a9, 0x4a},
	{0x04ab, 0x1f},
	{0x04ac, 0x0c},
	{0x04af, 0x1c},
	{0x04b0, 0xbc},
	{0x04b1, 0x4a},
	{0x04b3, 0x7f},
	{0x04b4, 0x0c},
	{0x04b7, 0x43},
	{0x04b8, 0xbc},
	{0x04b9, 0x4a},
	{0x04bb, 0xff},
	{0x04bc, 0x10},
	{0x04bf, 0x22},
	{0x04c0, 0x9c},
	{0x04c1, 0x60},
	{0x04c2, 0x33},
	{0x04c3, 0x01},
	{0x04c4, 0x84},
	{0x04c5, 0x90},
	{0x04c8, 0x8c},
	{0x04c9, 0xa4},
	{0x04cb, 0x8b},
	{0x04cc, 0x9c},
	{0x04cd, 0x80},
	{0x04cf, 0x1c},
	{0x04d0, 0x07},
	{0x04d1, 0xfb},
	{0x04d2, 0x19},
	{0x04d3, 0xe1},
	{0x04d4, 0x15},
	{0x04d8, 0x84},
	{0x04d9, 0x90},
	{0x04dc, 0x9c},
	{0x04dd, 0x60},
	{0x04de, 0x36},
	{0x04df, 0x31},
	{0x04e0, 0x8c},
	{0x04e1, 0xa4},
	{0x04e3, 0x8b},
	{0x04e4, 0x9c},
	{0x04e5, 0x80},
	{0x04e7, 0x88},
	{0x04e8, 0x07},
	{0x04e9, 0xfb},
	{0x04ea, 0x19},
	{0x04eb, 0xdb},
	{0x04ec, 0x15},
	{0x04f0, 0x84},
	{0x04f1, 0x90},
	{0x04f4, 0x9c},
	{0x04f5, 0x60},
	{0x04f6, 0x36},
	{0x04f7, 0x6f},
	{0x04f8, 0x8c},
	{0x04f9, 0xa4},
	{0x04fb, 0x8b},
	{0x04ff, 0x5b},
	{0x0500, 0x9c},
	{0x0501, 0x80},
	{0x0503, 0x2f},
	{0x0504, 0x10},
	{0x0507, 0x26},
	{0x0508, 0xbc},
	{0x0509, 0x4a},
	{0x050b, 0x7f},
	{0x050c, 0xb8},
	{0x050d, 0x8c},
	{0x050f, 0x42},
	{0x0510, 0x9e},
	{0x0511, 0x80},
	{0x0513, 0x01},
	{0x0514, 0x03},
	{0x0515, 0xff},
	{0x0516, 0xff},
	{0x0517, 0xd3},
	{0x0518, 0xa6},
	{0x0519, 0x44},
	{0x051a, 0xff},
	{0x051b, 0xff},
	{0x051c, 0x84},
	{0x051d, 0x90},
	{0x0520, 0x9c},
	{0x0521, 0x60},
	{0x0522, 0x33},
	{0x0523, 0x01},
	{0x0524, 0x8c},
	{0x0525, 0xa4},
	{0x0527, 0x8b},
	{0x0528, 0x07},
	{0x0529, 0xfb},
	{0x052a, 0x19},
	{0x052b, 0xcb},
	{0x052c, 0x9c},
	{0x052d, 0x80},
	{0x052f, 0x0b},
	{0x0530, 0x84},
	{0x0531, 0x90},
	{0x0534, 0x9c},
	{0x0535, 0x60},
	{0x0536, 0x36},
	{0x0537, 0x31},
	{0x0538, 0x8c},
	{0x0539, 0xa4},
	{0x053b, 0x8b},
	{0x053c, 0x03},
	{0x053d, 0xff},
	{0x053e, 0xff},
	{0x053f, 0xeb},
	{0x0540, 0x9c},
	{0x0541, 0x80},
	{0x0543, 0x84},
	{0x0544, 0x84},
	{0x0545, 0x90},
	{0x0548, 0x8c},
	{0x0549, 0xa4},
	{0x054b, 0x8b},
	{0x054c, 0x07},
	{0x054d, 0xfb},
	{0x054e, 0x19},
	{0x054f, 0xc2},
	{0x0550, 0x9c},
	{0x0551, 0x80},
	{0x0553, 0xff},
	{0x0554, 0x84},
	{0x0555, 0x90},
	{0x0558, 0x9c},
	{0x0559, 0x60},
	{0x055a, 0x36},
	{0x055b, 0x31},
	{0x055c, 0x8c},
	{0x055d, 0xa4},
	{0x055f, 0x8b},
	{0x0560, 0x07},
	{0x0561, 0xfb},
	{0x0562, 0x19},
	{0x0563, 0xbd},
	{0x0564, 0x9c},
	{0x0565, 0x80},
	{0x0567, 0x88},
	{0x0568, 0xbc},
	{0x0569, 0x32},
	{0x056b, 0x1f},
	{0x056c, 0x13},
	{0x056d, 0xff},
	{0x056e, 0xff},
	{0x056f, 0xe1},
	{0x0570, 0x15},
	{0x0574, 0xb8},
	{0x0575, 0x74},
	{0x0577, 0x02},
	{0x0578, 0x9c},
	{0x0579, 0x63},
	{0x057b, 0x03},
	{0x057c, 0xbd},
	{0x057d, 0xa3},
	{0x057f, 0x1e},
	{0x0580, 0x13},
	{0x0581, 0xff},
	{0x0582, 0xff},
	{0x0583, 0xdc},
	{0x0584, 0x15},
	{0x0588, 0x84},
	{0x0589, 0x90},
	{0x058c, 0x9c},
	{0x058d, 0x60},
	{0x058e, 0x36},
	{0x058f, 0x6f},
	{0x0590, 0x8c},
	{0x0591, 0xa4},
	{0x0593, 0x8b},
	{0x0597, 0x35},
	{0x0598, 0x9c},
	{0x0599, 0x80},
	{0x059b, 0x3c},
	{0x059c, 0x0c},
	{0x059f, 0x0e},
	{0x05a0, 0xb8},
	{0x05a1, 0x8c},
	{0x05a3, 0x43},
	{0x05a4, 0xbc},
	{0x05a5, 0x4a},
	{0x05a7, 0xff},
	{0x05a8, 0x10},
	{0x05ab, 0x18},
	{0x05ac, 0xbc},
	{0x05ad, 0x4a},
	{0x05ae, 0x01},
	{0x05af, 0xff},
	{0x05b0, 0xb8},
	{0x05b1, 0x8c},
	{0x05b3, 0x44},
	{0x05b4, 0x9e},
	{0x05b5, 0x80},
	{0x05b7, 0x07},
	{0x05b8, 0x03},
	{0x05b9, 0xff},
	{0x05ba, 0xff},
	{0x05bb, 0xaa},
	{0x05bc, 0xa6},
	{0x05bd, 0x44},
	{0x05be, 0xff},
	{0x05bf, 0xff},
	{0x05c0, 0x84},
	{0x05c1, 0x90},
	{0x05c4, 0x9c},
	{0x05c5, 0x60},
	{0x05c6, 0x33},
	{0x05c7, 0x01},
	{0x05c8, 0x8c},
	{0x05c9, 0xa4},
	{0x05cb, 0x8b},
	{0x05cc, 0x03},
	{0x05cd, 0xff},
	{0x05ce, 0xff},
	{0x05cf, 0xc1},
	{0x05d0, 0x9c},
	{0x05d1, 0x80},
	{0x05d3, 0x15},
	{0x05d4, 0x9e},
	{0x05d5, 0x80},
	{0x05d7, 0x03},
	{0x05d8, 0x03},
	{0x05d9, 0xff},
	{0x05da, 0xff},
	{0x05db, 0xa2},
	{0x05dc, 0xa6},
	{0x05dd, 0x44},
	{0x05de, 0xff},
	{0x05df, 0xff},
	{0x05e0, 0x84},
	{0x05e1, 0x70},
	{0x05e4, 0xa8},
	{0x05e5, 0x8a},
	{0x05e8, 0x8c},
	{0x05e9, 0xa3},
	{0x05eb, 0x8b},
	{0x05ec, 0x07},
	{0x05ed, 0xfb},
	{0x05ee, 0x19},
	{0x05ef, 0x9a},
	{0x05f0, 0x94},
	{0x05f1, 0x63},
	{0x05f3, 0xb0},
	{0x05f4, 0x84},
	{0x05f5, 0x70},
	{0x05f8, 0xb8},
	{0x05f9, 0x8c},
	{0x05fb, 0x49},
	{0x05fc, 0x8c},
	{0x05fd, 0xa3},
	{0x05ff, 0x8b},
	{0x0600, 0x03},
	{0x0601, 0xff},
	{0x0602, 0xff},
	{0x0603, 0xa8},
	{0x0604, 0x94},
	{0x0605, 0x63},
	{0x0607, 0xb2},
	{0x0608, 0x0c},
	{0x060b, 0x09},
	{0x060c, 0xb8},
	{0x060d, 0x8c},
	{0x060f, 0x45},
	{0x0610, 0xbc},
	{0x0611, 0x4a},
	{0x0612, 0x03},
	{0x0613, 0xff},
	{0x0614, 0x10},
	{0x0617, 0x09},
	{0x0618, 0xbc},
	{0x0619, 0x4a},
	{0x061a, 0x07},
	{0x061b, 0xff},
	{0x061c, 0xb8},
	{0x061d, 0x8c},
	{0x061f, 0x46},
	{0x0620, 0x9e},
	{0x0621, 0x80},
	{0x0623, 0x1f},
	{0x0624, 0x03},
	{0x0625, 0xff},
	{0x0626, 0xff},
	{0x0627, 0x8f},
	{0x0628, 0xa6},
	{0x0629, 0x44},
	{0x062a, 0xff},
	{0x062b, 0xff},
	{0x062c, 0x9e},
	{0x062d, 0x80},
	{0x062f, 0x0f},
	{0x0630, 0x03},
	{0x0631, 0xff},
	{0x0632, 0xff},
	{0x0633, 0x8c},
	{0x0634, 0xa6},
	{0x0635, 0x44},
	{0x0636, 0xff},
	{0x0637, 0xff},
	{0x0638, 0x10},
	{0x063b, 0x06},
	{0x063c, 0xbc},
	{0x063d, 0x4a},
	{0x063e, 0x0f},
	{0x063f, 0xff},
	{0x0640, 0xb8},
	{0x0641, 0x8c},
	{0x0643, 0x47},
	{0x0644, 0x9e},
	{0x0645, 0x80},
	{0x0647, 0x3f},
	{0x0648, 0x03},
	{0x0649, 0xff},
	{0x064a, 0xff},
	{0x064b, 0x86},
	{0x064c, 0xa6},
	{0x064d, 0x44},
	{0x064e, 0xff},
	{0x064f, 0xff},
	{0x0650, 0x13},
	{0x0651, 0xff},
	{0x0652, 0xff},
	{0x0653, 0x84},
	{0x0654, 0x15},
	{0x0658, 0xb8},
	{0x0659, 0x8c},
	{0x065b, 0x48},
	{0x065c, 0x9e},
	{0x065d, 0x80},
	{0x065f, 0x7f},
	{0x0660, 0x03},
	{0x0661, 0xff},
	{0x0662, 0xff},
	{0x0663, 0x80},
	{0x0664, 0xa6},
	{0x0665, 0x44},
	{0x0666, 0xff},
	{0x0667, 0xff},
	{0x0668, 0x07},
	{0x0669, 0xfb},
	{0x066a, 0x19},
	{0x066b, 0x7b},
	{0x066c, 0x15},
	{0x0670, 0x84},
	{0x0671, 0x90},
	{0x0674, 0x9c},
	{0x0675, 0x60},
	{0x0676, 0x33},
	{0x0677, 0x14},
	{0x0678, 0x8c},
	{0x0679, 0xa4},
	{0x067b, 0x8b},
	{0x067c, 0x07},
	{0x067d, 0xfb},
	{0x067e, 0x19},
	{0x067f, 0x76},
	{0x0680, 0x9c},
	{0x0681, 0x80},
	{0x0683, 0x02},
	{0x0684, 0x84},
	{0x0685, 0x90},
	{0x0688, 0x9c},
	{0x0689, 0x60},
	{0x068a, 0x38},
	{0x068b, 0x12},
	{0x068c, 0x8c},
	{0x068d, 0xa4},
	{0x068f, 0x8b},
	{0x0690, 0x07},
	{0x0691, 0xfb},
	{0x0692, 0x19},
	{0x0693, 0x71},
	{0x0694, 0x9c},
	{0x0695, 0x80},
	{0x0697, 0x30},
	{0x0698, 0x85},
	{0x0699, 0x21},
	{0x069c, 0x85},
	{0x069d, 0x41},
	{0x069f, 0x04},
	{0x06a0, 0x85},
	{0x06a1, 0x81},
	{0x06a3, 0x08},
	{0x06a4, 0x85},
	{0x06a5, 0xc1},
	{0x06a7, 0x0c},
	{0x06a8, 0x86},
	{0x06a9, 0x01},
	{0x06ab, 0x10},
	{0x06ac, 0x86},
	{0x06ad, 0x41},
	{0x06af, 0x14},
	{0x06b0, 0x86},
	{0x06b1, 0x81},
	{0x06b3, 0x18},
	{0x06b4, 0x44},
	{0x06b6, 0x48},
	{0x06b8, 0x9c},
	{0x06b9, 0x21},
	{0x06bb, 0x1c},
	{0x06bc, 0x9c},
	{0x06bd, 0x21},
	{0x06be, 0xff},
	{0x06bf, 0xf8},
	{0x06c0, 0xd4},
	{0x06c1, 0x01},
	{0x06c2, 0x48},
	{0x06c4, 0xd4},
	{0x06c5, 0x01},
	{0x06c6, 0x50},
	{0x06c7, 0x04},
	{0x06c8, 0xbc},
	{0x06c9, 0x03},
	{0x06ca, 0x01},
	{0x06cb, 0x11},
	{0x06cc, 0x10},
	{0x06cf, 0x25},
	{0x06d0, 0xbc},
	{0x06d1, 0x43},
	{0x06d2, 0x01},
	{0x06d3, 0x11},
	{0x06d4, 0x0c},
	{0x06d7, 0x07},
	{0x06d8, 0xbc},
	{0x06d9, 0x03},
	{0x06da, 0x01},
	{0x06db, 0x10},
	{0x06dc, 0xbc},
	{0x06dd, 0x03},
	{0x06de, 0x04},
	{0x06df, 0x0c},
	{0x06e0, 0x0c},
	{0x06e3, 0x35},
	{0x06e4, 0x15},
	{0x06eb, 0x31},
	{0x06ec, 0x15},
	{0x06f0, 0x0c},
	{0x06f3, 0x31},
	{0x06f4, 0x15},
	{0x06f8, 0x18},
	{0x06f9, 0xc0},
	{0x06fb, 0x14},
	{0x06fc, 0xa8},
	{0x06fd, 0xc6},
	{0x06fe, 0x02},
	{0x06ff, 0xb0},
	{0x0700, 0x19},
	{0x0701, 0x40},
	{0x0703, 0x14},
	{0x0704, 0xa9},
	{0x0705, 0x4a},
	{0x0706, 0x02},
	{0x0707, 0xf8},
	{0x0708, 0x84},
	{0x0709, 0x66},
	{0x070c, 0x84},
	{0x070d, 0xaa},
	{0x0710, 0x94},
	{0x0711, 0x83},
	{0x0713, 0x7e},
	{0x0714, 0xe4},
	{0x0715, 0xa4},
	{0x0716, 0x28},
	{0x0718, 0x10},
	{0x071b, 0x04},
	{0x071c, 0x9c},
	{0x071d, 0x80},
	{0x071f, 0x04},
	{0x0720, 0xd8},
	{0x0721, 0x03},
	{0x0722, 0x20},
	{0x0723, 0xd7},
	{0x0724, 0x84},
	{0x0725, 0x66},
	{0x0728, 0x94},
	{0x0729, 0xa3},
	{0x072b, 0x60},
	{0x072c, 0x84},
	{0x072d, 0x83},
	{0x072f, 0x64},
	{0x0730, 0xb8},
	{0x0731, 0x64},
	{0x0733, 0x44},
	{0x0734, 0xe0},
	{0x0735, 0xa3},
	{0x0736, 0x2b},
	{0x0737, 0x06},
	{0x0738, 0x18},
	{0x0739, 0x80},
	{0x073b, 0x14},
	{0x073c, 0xa8},
	{0x073d, 0x84},
	{0x073e, 0x02},
	{0x073f, 0xcc},
	{0x0740, 0x84},
	{0x0741, 0x64},
	{0x0744, 0xe0},
	{0x0745, 0x65},
	{0x0746, 0x1b},
	{0x0747, 0x06},
	{0x0748, 0x07},
	{0x0749, 0xfb},
	{0x074a, 0x05},
	{0x074b, 0xb8},
	{0x074c, 0xb8},
	{0x074d, 0x63},
	{0x074f, 0x42},
	{0x0750, 0x9c},
	{0x0751, 0x60},
	{0x0752, 0xff},
	{0x0753, 0xf0},
	{0x0754, 0xe1},
	{0x0755, 0x6b},
	{0x0756, 0x18},
	{0x0757, 0x03},
	{0x075b, 0x17},
	{0x075c, 0xd4},
	{0x075d, 0x0a},
	{0x075e, 0x58},
	{0x0760, 0x18},
	{0x0761, 0x60},
	{0x0763, 0x14},
	{0x0764, 0xa8},
	{0x0765, 0x63},
	{0x0766, 0x02},
	{0x0767, 0xb0},
	{0x0768, 0x84},
	{0x0769, 0x83},
	{0x076c, 0x84},
	{0x076d, 0xa4},
	{0x076f, 0x64},
	{0x0770, 0x18},
	{0x0771, 0x60},
	{0x0773, 0x14},
	{0x0774, 0xa8},
	{0x0775, 0x63},
	{0x0776, 0x02},
	{0x0777, 0xcc},
	{0x0778, 0x94},
	{0x0779, 0xc4},
	{0x077b, 0x60},
	{0x077c, 0xb8},
	{0x077d, 0xa5},
	{0x077f, 0x44},
	{0x0780, 0x84},
	{0x0781, 0xe3},
	{0x0784, 0x18},
	{0x0785, 0x80},
	{0x0787, 0x14},
	{0x0788, 0xa8},
	{0x0789, 0x84},
	{0x078a, 0x02},
	{0x078b, 0xf8},
	{0x078c, 0xe0},
	{0x078d, 0x65},
	{0x078e, 0x33},
	{0x078f, 0x06},
	{0x0790, 0xe0},
	{0x0791, 0x63},
	{0x0792, 0x3b},
	{0x0793, 0x06},
	{0x0794, 0x07},
	{0x0795, 0xfb},
	{0x0796, 0x06},
	{0x0797, 0x64},
	{0x0798, 0xb8},
	{0x0799, 0x63},
	{0x079b, 0x42},
	{0x079c, 0x18},
	{0x079d, 0x60},
	{0x079f, 0x14},
	{0x07a0, 0xa8},
	{0x07a1, 0x63},
	{0x07a2, 0x02},
	{0x07a3, 0xc0},
	{0x07a7, 0x04},
	{0x07a8, 0xd4},
	{0x07a9, 0x03},
	{0x07aa, 0x58},
	{0x07ac, 0x07},
	{0x07ad, 0xff},
	{0x07ae, 0xff},
	{0x07af, 0x0a},
	{0x07b0, 0x15},
	{0x07b4, 0x85},
	{0x07b5, 0x21},
	{0x07b8, 0x85},
	{0x07b9, 0x41},
	{0x07bb, 0x04},
	{0x07bc, 0x44},
	{0x07be, 0x48},
	{0x07c0, 0x9c},
	{0x07c1, 0x21},
	{0x07c3, 0x08},
	{0x07c4, 0x9c},
	{0x07c5, 0x21},
	{0x07c6, 0xff},
	{0x07c7, 0xfc},
	{0x07c8, 0xd4},
	{0x07c9, 0x01},
	{0x07ca, 0x48},
	{0x07cc, 0x07},
	{0x07cd, 0xff},
	{0x07ce, 0xff},
	{0x07cf, 0xbc},
	{0x07d0, 0x15},
	{0x07d4, 0x18},
	{0x07d5, 0x60},
	{0x07d7, 0x14},
	{0x07d8, 0xa8},
	{0x07d9, 0x63},
	{0x07da, 0x03},
	{0x07db, 0x18},
	{0x07dc, 0x9d},
	{0x07dd, 0x60},
	{0x07e0, 0x84},
	{0x07e1, 0x63},
	{0x07e4, 0xd4},
	{0x07e5, 0x03},
	{0x07e6, 0x59},
	{0x07e7, 0xcc},
	{0x07e8, 0xd4},
	{0x07e9, 0x03},
	{0x07ea, 0x59},
	{0x07eb, 0xc0},
	{0x07ec, 0xd4},
	{0x07ed, 0x03},
	{0x07ee, 0x59},
	{0x07ef, 0xc4},
	{0x07f0, 0xd4},
	{0x07f1, 0x03},
	{0x07f2, 0x59},
	{0x07f3, 0xc8},
	{0x07f4, 0x85},
	{0x07f5, 0x21},
	{0x07f8, 0x44},
	{0x07fa, 0x48},
	{0x07fc, 0x9c},
	{0x07fd, 0x21},
	{0x07ff, 0x04},

	{0xfffe, 0x50},
	{0x0137, 0x99},

	/*patch end*/

	{0xfffe, 0x30},
	{0x1f00, 0x00},
	{0x1f01, 0x00}, /*xstart*/
	{0x1f02, 0x00},
	{0x1f03, 0x00}, /*ystart*/
	{0x1f04, 0x07},
	{0x1f05, 0x80}, /*x_win*/
	{0x1f06, 0x04},
	{0x1f07, 0x38}, /*y_win*/
	{0x1f08, 0x03}, /*r_avg_ctrl, bit[1]:avg_opt; bit[0]:avg_man*/



	{0xfffe, 0x14},
	{0x003f, 0x10},
	{0x0040, 0x10},
	{0x0041, 0x10},
	{0x0042, 0x10},
	{0x0043, 0x10},
	{0x0044, 0x10},
	{0x0045, 0x10},
	{0x0046, 0x10},
	{0x0047, 0x10},
	{0x0048, 0x10},
	{0x0049, 0x10},
	{0x004a, 0x10},
	{0x004b, 0x10},
	{0x004c, 0x10},
	{0x004d, 0x10},
	{0x004e, 0x10},
	{0x004f, 0x10},
	{0x0050, 0x10},
	{0x0051, 0x10},
	{0x0052, 0x10},
	{0x0053, 0x10},
	{0x0054, 0x10},
	{0x0055, 0x10},
	{0x0056, 0x10},
	{0x0057, 0x10},
	{0x003a, 0x01},

	/*AE*/
	{0xfffe, 0x14},
	{0x0026, 0x01},   /*AEC enable*/
	{0x0035, 0x01},
	{0x00be, 0x60},  	/*camera i2c id*/
	{0x00bf, 0x01},  	/*camera i2c bits*/
	{0x00c0, 0x05}, /*5 	//sensor type gain*/
	{0x00c1, 0x00},  	/*sensor type exposure*/
	/*0x00c2,0x02,    //sensor mode select*/

	/*exposure*/

	{0x00c6, 0x3e},  /*write camera exposure variable [11:4]*/
	{0x00c7, 0x01},
	{0x00c8, 0x3e},  /*write camera exposure variable [3:0]*/
	{0x00c9, 0x02},


	{0x00ce, 0x00},  /*camera exposure addr mask 2*/
	{0x00cf, 0xff},
	{0x00d0, 0x00},  /*camera exposure addr mask 3*/
	{0x00d1, 0x0f},


	/*gain*/
	{0x00e4, 0x00},  /*camera gain addr*/
	{0x00e5, 0x00},
	{0x00e6, 0x00},  /*camera gain addr*/
	{0x00e7, 0x00},
	{0x00e8, 0x00},  /*camera gain addr*/
	{0x00e9, 0x00},
	{0x00ea, 0x00},  /*/camera gain addr*/
	{0x00eb, 0x00},

	{0x00ec, 0x00},  /*camera gain addr mask 1*/
	{0x00ed, 0x00},
	{0x00ee, 0x00},  /*camera gain addr mask 2*/
	{0x00ef, 0x00},
	{0x00f0, 0x00},  /*camera gain addr mask 3*/
	{0x00f1, 0x00},
	{0x00f0, 0x00},  /*camera gain addr mask 4*/
	{0x00f1, 0x00},

	/*banding*/
	{0x00b4, 0x02},    /* banding mode*/
	{0x00b6, 0x12},    /* 60HZ*/
	{0x00b7, 0xc0},
	{0x00b8, 0x16},    /* 50HZ*/
	{0x00b9, 0x80},

	/* AE CFG */
	{0xfffe, 0x14},
	{0x00aa, 0x02},
	{0x00ab, 0x40},   /*max gain*/
	{0x00ac, 0x00},
	{0x00ad, 0x20},   /*min gain*/

	{0x0092, 0x43},   /*Max Exposure Lines*/
	{0x0093, 0x80},   /*Max Exposure Lines*/
	{0x008e, 0x0b},   /*MIN Exposure Lines*/
	{0x008f, 0x00},   /*MIN Exposure Lines*/

	{0x00ba, 0x00},    /*low light mode*/
	{0x006a, 0x01},
	{0x006b, 0x40},   /*night target*/
	{0x006c, 0x01},
	{0x006d, 0xe0},   /*day target*/
	{0x0073, 0x20},   /*AttAvgReviseDiff*/

	/*AE SPEED*/
	{0xfffe, 0x14},
	{0x0039, 0x0},    /*DETECT enable*/
	{0x0060, 0x0},    /*smart mode 03*/

	{0x0076, 0x03},     /* delay frame*/
	{0x0079, 0x01},    /*fine exposure mode*/
	{0x007a, 0x00},
	{0x007b, 0x28},		/*1. threshold low*/
	{0x007c, 0x00},
	{0x007d, 0xb0},   /*2. threshold high*/
	{0x0077, 0x10},    /*3. finally thr*/
	{0x0078, 0x01},    /*total speed*/



	{0x007e, 0x00},
	{0x007f, 0x00},
	{0x0080, 0xff},
	{0x0081, 0xff},
	{0x0084, 0x00},
	{0x0085, 0x40},
	{0x0086, 0xff},
	{0x0087, 0xff},  /* jump ratio*/
	{0x0088, 0x00},  /* jump times*/


	{0x008a, 0x00},
	{0x008b, 0x00},   /*low threshold in high speed area*/
	{0x008c, 0x02},
	{0x008d, 0xc0},   /*high threshold in high speed area*/

	/* AE SMART */
	{0xfffe, 0x14},
	{0x005c, 0x00},
	{0x005d, 0xe7},
	{0x005e, 0x38},
	{0x005f, 0x00},
	{0x003a, 0x01},

	{0x0110, 0x00},
	{0x0112, 0x03},   /*Att Detect Speed*/
	{0x0113, 0x3},
	{0x0114, 0x3},		/* below or above cnt*/
	{0x011a, 0x00},
	{0x011b, 0x60},   /*day min attention  avg thr*/
	{0x011c, 0x02},
	{0x011d, 0x80},   /*day max attention  avg thr*/
	{0x011e, 0x00},
	{0x011f, 0x40},   /*day min avg thr*/
	{0x0120, 0x02},
	{0x0121, 0xc0},   /*day max avg thr*/
	{0x0062, 0x00},
	{0x0063, 0x60},    /* D-N*/
	{0x0064, 0x00},
	{0x0065, 0x40},    /* N-D*/
	{0x0066, 0x01},
	{0X0067, 0x00},    /*dark thr*/
	{0x0074, 0x20},    /*diff ratio low*/
	{0x0075, 0x40},    /*diff ratio high*/
	{0x006e, 0x6},     /*magnituede offset*/
	{0x006f, 0x1},     /*magnituede MIN*/
	{0x012a, 0x05},   /*variance thr promote luma*/
	{0x012b, 0x00},
	{0x012c, 0x00},   /*variance ratio*/
	{0x012d, 0x30},

	{0xfffe, 0x30},/*lenc_90%*/
	{0x0200, 0x15},
	{0x0201, 0xb},
	{0x0202, 0x8},
	{0x0203, 0x9},
	{0x0204, 0xe},
	{0x0205, 0x1f},
	{0x0206, 0x3},
	{0x0207, 0x3},
	{0x0208, 0x3},
	{0x0209, 0x3},
	{0x020a, 0x3},
	{0x020b, 0x4},
	{0x020c, 0x3},
	{0x020d, 0x1},
	{0x020e, 0x0},
	{0x020f, 0x1},
	{0x0210, 0x2},
	{0x0211, 0x3},
	{0x0212, 0x2},
	{0x0213, 0x1},
	{0x0214, 0x0},
	{0x0215, 0x0},
	{0x0216, 0x1},
	{0x0217, 0x3},
	{0x0218, 0x3},
	{0x0219, 0x2},
	{0x021a, 0x2},
	{0x021b, 0x2},
	{0x021c, 0x3},
	{0x021d, 0x3},
	{0x021e, 0xc},
	{0x021f, 0x6},
	{0x0220, 0x5},
	{0x0221, 0x5},
	{0x0222, 0x7},
	{0x0223, 0x12},
	{0x0224, 0x13},
	{0x0225, 0x33},
	{0x0226, 0x33},
	{0x0227, 0x33},
	{0x0228, 0x3 },
	{0x022a, 0x52},
	{0x022b, 0x51},
	{0x022c, 0x51},
	{0x022d, 0x51},
	{0x022e, 0x52},
	{0x0230, 0x51},
	{0x0231, 0x51},
	{0x0232, 0x51},
	{0x0233, 0x51},
	{0x0234, 0x51},
	{0x0236, 0x52},
	{0x0237, 0x51},
	{0x0238, 0x51},
	{0x0239, 0x51},
	{0x023a, 0x52},
	{0x023c, 0x23},
	{0x023d, 0x43},
	{0x023e, 0x42},
	{0x023f, 0x33},
	{0x0240, 0x13},
	{0x0248, 0xbf},

	{0xfffe, 0x30},
	{0x024d, 0x00},
	{0x024e, 0xCC},
	{0x024f, 0x01},
	{0x0250, 0x6C},
	{0x0251, 0x01},
	{0x0252, 0x11},
	{0x0253, 0x00},
	{0x0254, 0xF2},
	{0xfffe, 0x30},
	{0x0013, 0x10},

	/*AWB*/
	{0xfffe, 0x14},   /*AWB_init*/
	{0x0027, 0x01},  /*firmware中 awb_enable*/
	{0x013c, 0x02},  /*0.AWB_ARITH_ORIGIN  1.AWB_SW_PRO  2.AWB_ARITH_MANUAL*/
	{0x0176, 0x07},   /*int B gain*/
	{0x0177, 0x70},
	{0x017a, 0x04},  /*int Gb gain*/
	{0x017b, 0x00},
	{0x017e, 0x04},   /*int Gr gain*/
	{0x017f, 0x00},
	{0x0182, 0x06},   /*int R gain*/
	{0x0183, 0x21},
	{0x01aa, 0x07},    /*B_temp*/
	{0x01ab, 0x70},
	{0x01ae, 0x04},    /*G_ temp*/
	{0x01af, 0x00},
	{0x01b2, 0x06},   /*R_temp*/
	{0x01b3, 0x21},

	{0xfffe, 0x14},   /*C_AWB*/
	{0x0027, 0x00},  /*firmware中 awb_enable*/
	{0x013c, 0x01},  /*0.AWB_ARITH_ORIGIN  1.AWB_SW_PRO  2.AWB_ARITH_MANUAL*/
	{0x013d, 0x01},  /*AWBFlexiMap_en*/
	{0x013e, 0x00},  /*AWBMove_en*/
	{0x0143, 0x10},
	{0x014b, 0x00},
	{0x0153, 0x00},
	{0x0170, 0x0d},  /*nMaxAwbGain*/
	{0x0171, 0xff},


	{0xfffe, 0x30},
	{0x0708, 0x03}, /*pixel max value[9:8]*/
	{0x0709, 0xf0}, /*pixel max value[7:0]*/
	{0x070a, 0x00}, /*pixel min value[9:8]*/
	{0x070b, 0x0c}, /*pixel min value[7:0]*/
	{0x0001, 0x67},
	{0x0003, 0xe5},
	{0x0051, 0x03},
	{0x0096, 0x83},
	{0x0019, 0x48},
	{0x071c, 0x0a},  /*Simple_awb_en[4]: 0’b0: simple awb mode disenable 1’b1: simple awb mode enable*/

	{0xfffe, 0x14},
	{0x016e, 0x08},

	{0xfffd, 0x80},  /*AWB_4*/
	{0xfffe, 0x30},
	{0x0000, 0x4f},
	{0x0001, 0xa5},
	{0x0003, 0xe5},
	{0x0730, 0x5e},  /* win1 startx*/
	{0x0731, 0x7e},  /* win1 endx*/
	{0x0732, 0x36},  /* win1 starty*/
	{0x0733, 0x4f},  /* win1 endy*/
	{0x0734, 0x58},  /* win2 startx*/
	{0x0735, 0x7a},  /* win2 endx*/
	{0x0736, 0x4a}, /*60 // win2 starty*/
	{0x0737, 0x62},  /* win2 endy*/
	{0x0738, 0x3f},  /* win3 startx*/
	{0x0739, 0x62},  /* win3 endx*/
	{0x073a, 0x50},  /* win3 starty*/
	{0x073b, 0x76},  /* win3 endy*/
	{0x073c, 0x50},  /* win4 startx*/
	{0x073d, 0x6a},  /* win4 endx*/
	{0x073e, 0x3c},  /* win4 starty*/
	{0x073f, 0x50},  /* win4 endy*/
	{0x0740, 0x4a},  /* win5 startx*/
	{0x0741, 0x62},  /* win5 endx*/
	{0x0742, 0x50},  /* win5 starty*/
	{0x0743, 0x76},  /* win5 endy*/
	{0x0744, 0x00},  /* win6 startx*/
	{0x0745, 0x00},  /* win6 endx*/
	{0x0746, 0x00},  /* win6 starty*/
	{0x0747, 0x00},  /* win6 endy*/
	{0x0748, 0x00},  /* win7 startx*/
	{0x0749, 0x00},  /* win7 endx*/
	{0x074a, 0x00},  /* win7 starty*/
	{0x074b, 0x00},  /* win7 endy*/
	{0x074c, 0x00},  /* win8 startx*/
	{0x074d, 0x00},  /* win8 endx*/
	{0x074e, 0x00},  /* win8 starty*/
	{0x074f, 0x00},  /* win8 endy*/
	{0x0750, 0x00},  /* win9 startx*/
	{0x0751, 0x00},  /* win9 endx*/
	{0x0752, 0x00},  /* win9 starty*/
	{0x0753, 0x00},  /* win9 endy*/
	{0x0754, 0x00},  /* win10 startx*/
	{0x0755, 0x00},  /* win10 endx*/
	{0x0756, 0x00},  /* win10 starty*/
	{0x0757, 0x00},  /* win10 endy*/
	{0x0758, 0x00},  /* win11 startx*/
	{0x0759, 0x00},  /* win11 endx*/
	{0x075a, 0x00},  /* win11 starty*/
	{0x075b, 0x00},  /* win11 endy*/
	{0x075c, 0x00},  /* win12 startx*/
	{0x075d, 0x00},  /* win12 endx*/
	{0x075e, 0x00},  /* win12 starty*/
	{0x075f, 0x00},  /* win12 endy*/
	{0x0760, 0x00},  /* win13 startx*/
	{0x0761, 0x00},  /* win13 endx*/
	{0x0762, 0x00},  /* win13 starty*/
	{0x0763, 0x00},  /* win13 endy*/
	{0x0764, 0x00},  /* win14 startx*/
	{0x0765, 0x00},  /* win14 endx*/
	{0x0766, 0x00},  /* win14 starty*/
	{0x0767, 0x00},  /* win14 endy*/
	{0x0768, 0x00},  /* win15 startx*/
	{0x0769, 0x00},  /* win15 endx*/
	{0x076a, 0x00},  /* win15 starty*/
	{0x076b, 0x00},  /* win15 endy*/
	{0x076c, 0x00},  /* win16 startx*/
	{0x076d, 0x00},  /* win16 endx*/
	{0x076e, 0x00},  /* win16 starty*/
	{0x076f, 0x00},  /* win16 endy*/
	{0x0770, 0x22},  /* wt1 wt2*/
	{0x0771, 0x21},  /* wt3 wt4*/
	{0x0772, 0x00},  /* wt5 wt6*/
	{0x0773, 0x00},  /* wt7 wt8*/
	{0x0774, 0x00},  /* wt9 wt10*/
	{0x0775, 0x00},  /* wt11 wt12*/
	{0x0776, 0x00},  /* wt13 wt14*/
	{0x0777, 0x00},  /* wt15 wt16*/

	/*	//gamma */
	{0xfffd, 0x80},
	{0xfffe, 0x30},
	{0x1400, 0x00},
	{0x1401, 0x08},
	{0x1402, 0x0f},
	{0x1403, 0x17},
	{0x1404, 0x1e},
	{0x1405, 0x25},
	{0x1406, 0x2c},
	{0x1407, 0x33},
	{0x1408, 0x3a},
	{0x1409, 0x40},
	{0x140a, 0x46},
	{0x140b, 0x4c},
	{0x140c, 0x51},
	{0x140d, 0x56},
	{0x140e, 0x5b},
	{0x140f, 0x60},
	{0x1410, 0x65},
	{0x1411, 0x69},
	{0x1412, 0x6d},
	{0x1413, 0x70},
	{0x1414, 0x74},
	{0x1415, 0x77},
	{0x1416, 0x7a},
	{0x1417, 0x7d},
	{0x1418, 0x80},
	{0x1419, 0x82},
	{0x141a, 0x85},
	{0x141b, 0x87},
	{0x141c, 0x89},
	{0x141d, 0x8b},
	{0x141e, 0x8d},
	{0x141f, 0x8f},
	{0x1420, 0x91},
	{0x1421, 0x94},
	{0x1422, 0x98},
	{0x1423, 0x9b},
	{0x1424, 0x9e},
	{0x1425, 0xa1},
	{0x1426, 0xa4},
	{0x1427, 0xa7},
	{0x1428, 0xa9},
	{0x1429, 0xac},
	{0x142a, 0xaf},
	{0x142b, 0xb1},
	{0x142c, 0xb4},
	{0x142d, 0xb7},
	{0x142e, 0xb9},
	{0x142f, 0xbb},
	{0x1430, 0xbe},
	{0x1431, 0xc3},
	{0x1432, 0xc7},
	{0x1433, 0xcc},
	{0x1434, 0xd0},
	{0x1435, 0xd4},
	{0x1436, 0xd9},
	{0x1437, 0xdd},
	{0x1438, 0xe1},
	{0x1439, 0xe5},
	{0x143a, 0xe9},
	{0x143b, 0xed},
	{0x143c, 0xf0},
	{0x143d, 0xf4},
	{0x143e, 0xf8},
	{0x143f, 0xfc},
	{0x1440, 0xff},

	{0xfffe, 0x30},  /*Setting_A_Rb+0.2_Br+0.1_Bg-0.2_Gb-0.4_Rg-0.2.txt*/

	{0x1200, 0xA},		/*DAY*/
	{0x1201, 0xA5},
	{0x1202, 0x0},
	{0x1203, 0x60},
	{0x1204, 0x0},
	{0x1205, 0x9C},
	{0x1206, 0x1},
	{0x1207, 0x32},
	{0x1208, 0x1},
	{0x1209, 0x4E},
	{0x120A, 0x3},
	{0x120B, 0x26},
	{0x120C, 0x0f},		/*ALIGHT*/
	{0x120D, 0xff},
	{0x120E, 0x0},
	{0x120F, 0xa0},
	{0x1210, 0x2},
	{0x1211, 0x0},
	{0x1212, 0x1},
	{0x1213, 0xf0},
	{0x1214, 0x0},
	{0x1215, 0x00},
	{0x1216, 0x1},
	{0x1217, 0x40},
	{0x1218, 0xC},		/*CWF*/
	{0x1219, 0xB9},
	{0x121A, 0x0},
	{0x121B, 0xA0},
	{0x121C, 0x1},
	{0x121D, 0x15},
	{0x121E, 0x1},
	{0x121F, 0xEB},
	{0x1220, 0x1},
	{0x1221, 0x97},
	{0x1222, 0x4},
	{0x1223, 0xCB},
	{0x122e, 0x2},		/*sign*/
	{0x122F, 0x0},
	{0x1230, 0xA},
	{0x1228, 0x0},
	{0x1229, 0x5C},
	{0x122A, 0x0},
	{0x122B, 0x98},
	{0x122C, 0x0},
	{0x122D, 0xE2},

	{0xfffe, 0x30},
	{0x1231, 0x02},

	{0xfffe, 0x30},   /*YEE*/
	{0x2000, 0x3f},   /*bit[5]Yedge en; bit[3]UV_dns_en; bit[2]pre_dns_en; bit[1]ydns_man; bit[0]uvdns_man*/
	{0x2001, 0x00},  /*edge_ratio*/
	{0x2002, 0x02}, /*Y_dns_level_man*/
	{0x2003, 0x10}, /*UV_dns_level_man*/
	{0x2004, 0x01},    /*gain list0*/
	{0x2005, 0x01},
	{0x2006, 0x02},
	{0x2007, 0x03},
	{0x2008, 0x04},
	{0x2009, 0x05},
	{0x200a, 0x06},
	{0x200b, 0x1f},   /*gain list7*/

	{0x1907, 0x3a},  /*y_win+2*/
	{0x1908, 0x01}, /*win_man_en*/

	{0xfffe, 0x30},   /*RAW_DNS*/
	{0x0e00, 0x34}, /*34 //bit[5] Para_man_en  bit[4]G_en*/
	{0x0e01, 0x08}, /*06 //noise list0*/
	{0x0e02, 0x0f}, /*0c*/
	{0x0e03, 0x14}, /*10*/
	{0x0e04, 0x24}, /*20*/
	{0x0e05, 0x34}, /*30*/
	{0x0e06, 0x38},
	{0x0e07, 0x38},
	{0x0e08, 0x38},    /*noise list7*/
	{0x0e09, 0x3f},    /*max_edge_thre*/
	{0x0e0a, 0x06}, /*noise_man*/
	{0x0e0b, 0x20},  /*edgethre_man*/

	{0xfffe, 0x30},   /*RGB_DNS*/
	{0x130e, 0x08},  /*bit[3] Para_man_en  bit[2:0]Y_noise_man*/
	{0x130f, 0x0f},  /* bit[5:0]UV_noise_man*/

	{0xfffe, 0x30},   /*cip*/
	{0x0f00, 0x30},   /*bit[7:4] noise_y_slp  bit[3:0] Lsharp*/
	{0x0f01, 0x00},
	{0x0f02, 0x08},/*noise list0*/
	{0x0f03, 0x0f},
	{0x0f04, 0x14},
	{0x0f05, 0x24},
	{0x0f06, 0x34},
	{0x0f07, 0x38},
	{0x0f08, 0x38},
	{0x0f09, 0x38},  /*noise list7*/
	{0x0f0a, 0x04},  /*min_shp*/
	{0x0f0b, 0x20},  /*max_shp*/
	{0x0f0c, 0x01},  /*min_detail*/
	{0x0f0d, 0x20},  /*max_detail*/
	{0x0f0e, 0x01},   /*min_shp_gain*/
	{0x0f0f, 0x20},   /*max_shp_gain*/

	{0xfffe, 0x14}, /*saturation adjust*/
	{0x0160, 0x00},/*bAutoSat_en*/
	{0x0162, 0x44},/*sat_u[0]*/
	{0x0163, 0x3d},/*sat_u[1]*/
	{0x0164, 0x36},/*sat_u[2]*/
	{0x0165, 0x30},/*sat_u[3]*/
	{0x0166, 0x2c},/*sat_u[4]*/
	{0x0167, 0x26},/*sat_u[5]*/
	{0x0168, 0x40},/*sat_v[0]*/
	{0x0169, 0x38},/*sat_v[1]*/
	{0x016a, 0x30},/*sat_v[2]*/
	{0x016b, 0x2c},/*sat_v[3]*/
	{0x016c, 0x28},/*sat_v[4]*/
	{0x016d, 0x24},/*sat_v[5]*/

	/*TOP*/
	{0xfffe, 0x30},
	{0x0000, 0xcf},  /*LENC OPEN*/
	{0x0001, 0xad},  /*a7*/
	{0x0003, 0xe5},
	{0x0013, 0x06},
	{0x0716, 0x00},
	{0x071c, 0x0a},
	{0x1700, 0x09},
	{0x1701, 0x30},
	{0x1702, 0x28},
	{0x1704, 0x23},
	{0xfffe, 0x14},
	{0x0027, 0x01},
};

static struct regval_list SC2233dvp_default_regs[] = { /* 1920x1080@30fps */
	/* SC2233_1920X1080_SET */
	{0x0103, 0x01},
	{0x0100, 0x00},

	{0x3621, 0x28},

	{0x3309, 0x60},
	{0x331f, 0x4d},
	{0x3321, 0x4f},
	{0x33b5, 0x10},

	{0x3303, 0x20},
	{0x331e, 0xd},
	{0x3320, 0xf},

	{0x3622, 0x02},
	{0x3633, 0x42},
	{0x3634, 0x42},

	{0x3306, 0x66},
	{0x330b, 0xd1},

	{0x3301, 0x0e},

	{0x320c, 0x08},
	{0x320d, 0x98},

	{0x3364, 0x05}, /* [2] 1: write at sampling ending */

	{0x363c, 0x28}, /* bypass nvdd */
	{0x363b, 0x0a}, /* HVDD */
	{0x3635, 0xa0}, /* TXVDD */

	{0x4500, 0x59},
	{0x3d08, 0x00},
	{0x3908, 0x04},

	{0x363c, 0x08},

	{0x3e03, 0x03},
	{0x3e01, 0x46},


	/* {0x3e08, 0x7f}, */
	/* {0x3e09, 0x1f}, */
	/* {0x5000, 0x00}, */
	/* {0x3908, 0x31}, */

	/*0703*/
	{0x3381, 0x0a},
	{0x3348, 0x09},
	{0x3349, 0x50},
	{0x334a, 0x02},
	{0x334b, 0x60},

	{0x3380, 0x04},
	{0x3340, 0x06},
	{0x3341, 0x50},
	{0x3342, 0x02},
	{0x3343, 0x60},

	/* 0707 */

	{0x3632, 0x88}, /* anti sm */
	{0x3309, 0xa0},
	{0x331f, 0x8d},
	{0x3321, 0x8f},

	{0x335e, 0x01}, /* ana dithering */
	{0x335f, 0x03},
	{0x337c, 0x04},
	{0x337d, 0x06},
	{0x33a0, 0x05},
	{0x3301, 0x05},

	/* atuo logic */

	{0x3670, 0x08}, /* [3]:3633 logic ctrl  real value in 3682 */
	{0x367e, 0x07}, /* gain0 */
	{0x367f, 0x0f}, /* gain1 */
	{0x3677, 0x2f}, /* <gain0 */
	{0x3678, 0x22}, /* gain0 - gain1 */
	{0x3679, 0x43}, /* >gain1 */

	/*
	*new auto precharge 330e in 3372 [7:6]
	*11: close div_rst
	*00:open div_rst
	*/
	{0x337f, 0x03},
	{0x3368, 0x02},
	{0x3369, 0x00},
	{0x336a, 0x00},
	{0x336b, 0x00},
	{0x3367, 0x08},
	{0x330e, 0x30},

	{0x3366, 0x7c}, /* div_rst gap */

	{0x3635, 0xc1},
	{0x363b, 0x09},
	{0x363c, 0x07},

	{0x391e, 0x00},

	{0x3637, 0x14}, /* fullwell 7K */

	{0x3306, 0x54},
	{0x330b, 0xd8},
	{0x366e, 0x08}, /* ofs auto en [3] */
	{0x366f, 0x2f}, /* ofs+finegain real ofs in 0x3687[4:0] */

	{0x3631, 0x84},
	{0x3630, 0x48},
	{0x3622, 0x06},

	/* ramp by sc */
	{0x3638, 0x1f},
	{0x3625, 0x02},
	{0x3636, 0x24},

	/*0714*/
	{0x3348, 0x08},
	{0x3e03, 0x0b},

	/*7.17 fpn*/
	{0x3342, 0x03},
	{0x3343, 0xa0},
	{0x334a, 0x03},
	{0x334b, 0xa0},

	/*0718*/
	{0x3343, 0xb0},
	{0x334b, 0xb0},

	/* 0720 */

	/* digital ctrl */
	{0x3802, 0x01},
	{0x3235, 0x04},
	{0x3236, 0x63}, /* vts-2 */

	/* fpn */
	{0x3343, 0xd0},
	{0x334b, 0xd0},
	{0x3348, 0x07},
	{0x3349, 0x80},

	/* 0724 */
	{0x391b, 0x4d},

	{0x3342, 0x04},
	{0x3343, 0x20},
	{0x334a, 0x04},
	{0x334b, 0x20},

	/* 0804 */
	{0x3222, 0x29},
	{0x3901, 0x02},

	/* 0808 */

	/* digital ctrl */
	{0x3f00, 0x07}, /* bit[2] = 1 */
	{0x3f04, 0x08},
	{0x3f05, 0x74}, /* hts - 0x24 */

	/* 0809 */
	{0x330b, 0xc8},

	/* 0817 */
	{0x3306, 0x4a},
	{0x330b, 0xca},
	{0x3639, 0x09},

	/* manual DPC */
	{0x5780, 0xff},
	{0x5781, 0x04},
	{0x5785, 0x18},

	/*0822*/
	{0x3039, 0x35},
	{0x303a, 0x2e},
	{0x3034, 0x05},
	{0x3035, 0x2a},

	{0x320c, 0x08},
	{0x320d, 0xca},
	{0x320e, 0x04},
	{0x320f, 0xb0},

	{0x3f04, 0x08},
	{0x3f05, 0xa6}, /* hts - 0x24 */

	{0x3235, 0x04},
	{0x3236, 0xae}, /* vts-2 */

	/* 0825 */
	{0x3313, 0x05},
	{0x3678, 0x42},

	/* for AE control per frame */
	{0x3670, 0x00},
	{0x3633, 0x42},

	{0x3802, 0x00},

	{0x0100, 0x01},
	/* {0x3640, 0x01}, //driver control */
	/* {0x3641, 0x01}, */
	{0x3221, 0x66},
};

static struct regval_list xc7021_480p_regs_15fps[] = { /* 640x480@15fps */
	{0xfffe, 0x26},
	{0x8010, 0x08},

	/* 15fps sensor */
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0004, 0x00},
	{0xfffd, 0x80},
	{0xfffe, 0x14},
	{0x1300, 0x02}, /* number of write regester */

	{0x1301, 0x32}, /* high address of first regester */
	{0x1302, 0x0e}, /* low address of first regester */
	{0x1303, 0x09}, /* value of first regester */
	{0x1304, 0x32}, /* high address of second regester */
	{0x1305, 0x0f}, /* low address of second regester */
	{0x1306, 0x20}, /* value of second regester */

	/* add as above */
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0007, 0x60}, /* sensor I2C address */
	{0x000d, 0x31}, /* [7:4]speed [3:0]mode */
	{0x0009, 0x00},
	{0x00c4, 0x10},
	{0x00c0, 0x01},

	{0xffff, 100}, /* delay 100, */

	/* ISP init */
	{0xfffe, 0x26},
	{0x6006, 0x5},
	{0x6007, 0x78},
	{0x6008, 0x4},

	{0x8010, 0x5},
	{0x8012, 0xA0},
	{0x8013, 0x5},
	{0x8016, 0xF0},

	{0xfffe, 0x30},
	{0x1f04, 0x05},
	{0x1f05, 0xA0}, /* x_win */

	{0x0001, 0x93},
	{0x0006, 0x5},
	{0x0007, 0xA0},
	{0x000a, 0x2},
	{0x000b, 0x80},
	{0x000c, 0x1},
	{0x000d, 0xE0},
	{0x0027, 0xF1},
	{0x005e, 0x5},
	{0x005f, 0x9F},
	{0x1904, 0x5},
	{0x1905, 0xA0},
	{0x1907, 0x38},
	{0x1908, 0x00},

	{0xffff, 100}, /* delay 100, */

	{0xfffe, 0x26},
	{0x8010, 0x0d},
};

static struct regval_list xc7021_480p_regs_30fps[] = { /* 640x480@30fps */
	{0xfffe, 0x26},
	{0x8010, 0x08},

	/* 30fps sensor */
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0004, 0x00},
	{0xfffd, 0x80},
	{0xfffe, 0x14},
	{0x1300, 0x02}, /* number of write regester */

	{0x1301, 0x32}, /* high address of first regester */
	{0x1302, 0x0e}, /* low address of first regester */
	{0x1303, 0x04}, /* value of first regester */
	{0x1304, 0x32}, /* high address of second regester */
	{0x1305, 0x0f}, /* low address of second regester */
	{0x1306, 0xb0}, /* value of second regester */

	/* add as above */
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0007, 0x60}, /* sensor I2C address */
	{0x000d, 0x31}, /* [7:4]speed [3:0]mode */
	{0x0009, 0x00},
	{0x00c4, 0x10},
	{0x00c0, 0x01},

	{0xffff, 100}, /* delay 100, */

	/* ISP init */
	{0xfffe, 0x26},
	{0x6006, 0x5},
	{0x6007, 0x78},
	{0x6008, 0x4},

	{0x8010, 0x5},
	{0x8012, 0xA0},
	{0x8013, 0x5},
	{0x8016, 0xF0},

	{0xfffe, 0x30},
	{0x1f04, 0x05},
	{0x1f05, 0xA0}, /* x_win */

	{0x0001, 0x93},
	{0x0006, 0x5},
	{0x0007, 0xA0},
	{0x000a, 0x2},
	{0x000b, 0x80},
	{0x000c, 0x1},
	{0x000d, 0xE0},
	{0x0027, 0xF1},
	{0x005e, 0x5},
	{0x005f, 0x9F},
	{0x1904, 0x5},
	{0x1905, 0xA0},
	{0x1907, 0x38},
	{0x1908, 0x00},

	{0xffff, 100}, /* delay 100, */

	{0xfffe, 0x26},
	{0x8010, 0x0d},
};

static struct regval_list xc7021_720p_regs_15fps[] = { /* 1280x720@15fps */
	{0xfffe, 0x26},
	{0x8010, 0x08},

	/* 15fps sensor */
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0004, 0x00},
	{0xfffd, 0x80},
	{0xfffe, 0x14},
	{0x1300, 0x02}, /* number of write regester */

	{0x1301, 0x32}, /* high address of first regester */
	{0x1302, 0x0e}, /* low address of first regester */
	{0x1303, 0x09}, /* value of first regester */
	{0x1304, 0x32}, /* high address of second regester */
	{0x1305, 0x0f}, /* low address of second regester */
	{0x1306, 0x20}, /* value of second regester */

	/* add as above */
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0007, 0x60}, /* sensor I2C address */
	{0x000d, 0x31}, /* [7:4]speed [3:0]mode */
	{0x0009, 0x00},
	{0x00c4, 0x10},
	{0x00c0, 0x01},

	{0xffff, 100},/* delay 100, */

	/* ISP init */
	{0xfffe, 0x26},
	{0x6006, 0xA},
	{0x6007, 0x8C},
	{0x6008, 0x9},

	{0x8010, 0x4},
	{0x8012, 0x80},
	{0x8013, 0x7},
	{0x8016, 0x0},

	{0xfffe, 0x30},
	{0x1f04, 0x07},
	{0x1f05, 0x80}, /* x_win */

	{0x0001, 0x93},
	{0x0006, 0x7},
	{0x0007, 0x80},
	{0x000a, 0x5},
	{0x000b, 0x00},
	{0x000c, 0x2},
	{0x000d, 0xD0},
	{0x0027, 0xF1},
	{0x005e, 0x7},
	{0x005f, 0x7F},
	{0x1904, 0x7},
	{0x1905, 0x80},
	{0x1907, 0x38},
	{0x1908, 0x00},

	{0xffff, 100},/* delay 100, */

	{0xfffe, 0x26},
	{0x8010, 0x0c},
};

static struct regval_list xc7021_720p_regs_30fps[] = { /* 1280x720@30fps */
	{0xfffe, 0x26},
	{0x8010, 0x08},

	/* 30fps sensor */
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0004, 0x00},
	{0xfffd, 0x80},
	{0xfffe, 0x14},
	{0x1300, 0x02}, /* number of write regester */

	{0x1301, 0x32}, /* high address of first regester */
	{0x1302, 0x0e}, /* low address of first regester */
	{0x1303, 0x04}, /* value of first regester */
	{0x1304, 0x32}, /* high address of second regester */
	{0x1305, 0x0f}, /* low address of second regester */
	{0x1306, 0xb0}, /* value of second regester */

	/* 按上述方式继续添加 */
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0007, 0x60}, /* sensor I2C address */
	{0x000d, 0x31}, /* [7:4]speed [3:0]mode */
	{0x0009, 0x00},
	{0x00c4, 0x10},
	{0x00c0, 0x01},

	{0xffff, 100}, /* delay 100, */

	/* ISP init */
	{0xfffe, 0x26},
	{0x6006, 0xA},
	{0x6007, 0x8C},
	{0x6008, 0x9},

	{0x8010, 0x4},
	{0x8012, 0x80},
	{0x8013, 0x7},
	{0x8016, 0x0},

	{0xfffe, 0x30},
	{0x1f04, 0x07},
	{0x1f05, 0x80}, /* x_win */

	{0x0001, 0x93},
	{0x0006, 0x7},
	{0x0007, 0x80},
	{0x000a, 0x5},
	{0x000b, 0x00},
	{0x000c, 0x2},
	{0x000d, 0xD0},
	{0x0027, 0xF1},
	{0x005e, 0x7},
	{0x005f, 0x7F},
	{0x1904, 0x7},
	{0x1905, 0x80},
	{0x1907, 0x38},
	{0x1908, 0x00},

	{0xffff, 100}, /* delay 100, */

	{0xfffe, 0x26},
	{0x8010, 0x0c},
};

static struct regval_list xc7021_1080p_regs_15fps[] = { /* 1980x1080@15fps */
	{0xfffe, 0x26},
	{0x8010, 0x08},

	/* 15fps sensor */
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0004, 0x00},
	{0xfffd, 0x80},
	{0xfffe, 0x14},
	{0x1300, 0x02}, /* number of write regester */

	{0x1301, 0x32}, /* high address of first regester */
	{0x1302, 0x0e}, /* low address of first regester */
	{0x1303, 0x09}, /* value of first regester */
	{0x1304, 0x32}, /* high address of second regester */
	{0x1305, 0x0f}, /* low address of second regester */
	{0x1306, 0x20}, /* value of second regester */

	/* add as above */
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0007, 0x60}, /* sensor I2C address */
	{0x000d, 0x31}, /* [7:4]speed [3:0]mode */
	{0x0009, 0x00},
	{0x00c4, 0x10},
	{0x00c0, 0x01},

	{0xffff, 100}, /* delay 100, */

	/* ISP init */
	{0xfffe, 0x26},
	{0x6006, 0xF},
	{0x6007, 0xA0},
	{0x6008, 0xE},

	{0x8010, 0x4},
	{0x8012, 0x80},
	{0x8013, 0x7},
	{0x8016, 0x0},

	{0xfffe, 0x30},
	{0x1f04, 0x07},
	{0x1f05, 0x80}, /* x_win */

	{0x0001, 0x87},
	{0x0006, 0x7},
	{0x0007, 0x80},
	{0x000a, 0x7},
	{0x000b, 0x80},
	{0x000c, 0x4},
	{0x000d, 0x38},
	{0x0027, 0xF7},
	{0x005e, 0x7},
	{0x005f, 0x7F},
	{0x1904, 0x7},
	{0x1905, 0x80},
	{0x1907, 0x3a},
	{0x1908, 0x01},

	{0xffff, 100}, /* delay 100, */

	{0xfffe, 0x26},
	{0x8010, 0x0c},
};

static struct regval_list xc7021_1080p_regs_30fps[] = { /* 1980x1080@30fps */
	{0xfffe, 0x26},
	{0x8010, 0x08},

	/* 30fps sensor */
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0004, 0x00},
	{0xfffd, 0x80},
	{0xfffe, 0x14},
	{0x1300, 0x02}, /* number of write regester */

	{0x1301, 0x32}, /* high address of first regester */
	{0x1302, 0x0e}, /* low address of first regester */
	{0x1303, 0x04}, /* value of first regester */
	{0x1304, 0x32}, /* high address of second regester */
	{0x1305, 0x0f}, /* low address of second regester */
	{0x1306, 0xb0}, /* value of second regester */

	/* add as above */
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0007, 0x60}, /* sensor I2C address */
	{0x000d, 0x31}, /* [7:4]speed [3:0]mode */
	{0x0009, 0x00},
	{0x00c4, 0x10},
	{0x00c0, 0x01},

	{0xffff, 100}, /* delay 100, */

	/* ISP init */
	{0xfffe, 0x26},
	{0x6006, 0xF},
	{0x6007, 0xA0},
	{0x6008, 0xE},

	{0x8010, 0x4},
	{0x8012, 0x80},
	{0x8013, 0x7},
	{0x8016, 0x0},

	{0xfffe, 0x30},
	{0x1f04, 0x07},
	{0x1f05, 0x80}, /* x_win */

	{0x0001, 0x87},
	{0x0006, 0x7},
	{0x0007, 0x80},
	{0x000a, 0x7},
	{0x000b, 0x80},
	{0x000c, 0x4},
	{0x000d, 0x38},
	{0x0027, 0xF7},
	{0x005e, 0x7},
	{0x005f, 0x7F},
	{0x1904, 0x7},
	{0x1905, 0x80},
	{0x1907, 0x3a},
	{0x1908, 0x01},

	{0xffff, 100}, /* delay 100, */

	{0xfffe, 0x26},
	{0x8010, 0x0c},
};

/*
 * Here we'll try to encapsulate the changes for just the output
 * video format.
 */

static struct regval_list sensor_fmt_yuv422_yuyv[] = {

};


static int sensor_write_sc2233(struct v4l2_subdev *sd, unsigned short reg,
				unsigned char value)
{
	int ret = 0;
	int cnt = 0;
	int addr;
	struct cci_driver *cci_drv = v4l2_get_subdevdata(sd);

	addr = cci_drv->cci_saddr;
	cci_drv->cci_saddr = I2C_ADDR_sc2233_SENSOR;

	ret = cci_write_a16_d8(sd, reg, value);
	while (ret != 0 && cnt < 2) {
		ret = cci_write_a16_d8(sd, reg, value);
		cnt++;
	}
	if (cnt > 0)
		sensor_dbg("sensor write retry=%d\n", cnt);
	cci_drv->cci_saddr = addr;
	return ret;
}


static int sensor_write_array_sc2233(struct v4l2_subdev *sd,
				struct regval_list *regs, int array_size)
{
	int ret = 0;
	int i = 0;
	struct cci_driver *cci_drv = v4l2_get_subdevdata(sd);

	if (!regs)
		return -EINVAL;
	sc2233_i2c_bypass(sd, 1);

	while (i < array_size) {
		if (0/* regs->addr == REG_DLY */) {  /* fix me???? */
			msleep(regs->data);
		} else {
			ret = sensor_write_sc2233(sd, regs->addr, regs->data);
			if (ret < 0)
				sensor_err("%s sensor write array error!!\n", cci_drv->name);
		}
		i++;
		regs++;
	}

	sc2233_i2c_bypass(sd, 0);
	return 0;
}

static int sensor_read_sc2233(struct v4l2_subdev *sd, unsigned short reg,
				unsigned char *value)
{
	int ret = -1;
	int cnt = 0;
	struct cci_driver *cci_drv = v4l2_get_subdevdata(sd);
	int addr = cci_drv->cci_saddr;

	cci_drv->cci_saddr = I2C_ADDR_sc2233_SENSOR;
	ret = cci_read_a16_d8(sd, reg, value);
	while (ret != 0 && cnt < 8) {
		ret = cci_read_a16_d8(sd, reg, value);
		cnt++;
	}
	cci_drv->cci_saddr = addr;
	if (cnt > 0)
		sensor_dbg("sensor read retry=%d\n", cnt);

	return ret;

}

static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
{
	struct sensor_info *info = to_state(sd);

	*value = info->exp;
	sensor_dbg("sensor_get_exposure = %d\n", info->exp);

	return 0;
}

/*
static int sensor_s_exp(struct v4l2_subdev *sd, unsigned int exp_val)
{
	struct sensor_info *info = to_state(sd);

	info->exp = exp_val;
	return 0;
}
*/

static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
{
	struct sensor_info *info = to_state(sd);

	*value = info->gain;
	sensor_dbg("sensor_get_gain = %d\n", info->gain);
	return 0;
}

/*
static int sensor_s_gain(struct v4l2_subdev *sd, int gain_val)
{
	struct sensor_info *info = to_state(sd);

	info->gain = gain_val;

	return 0;

}
*/

static int sensor_s_exp_gain(struct v4l2_subdev *sd,
				struct sensor_exp_gain *exp_gain)
{
	int exp_val, gain_val;
	struct sensor_info *info = to_state(sd);

	exp_val = exp_gain->exp_val;
	gain_val = exp_gain->gain_val;

	info->exp = exp_val;
	info->gain = gain_val;
	return 0;
}

static int sensor_s_sw_stby(struct v4l2_subdev *sd, int on_off)
{
	int ret = 0;
	return ret;
}

/*
 * Stuff that knows about the sensor.
 */

static int sensor_power(struct v4l2_subdev *sd, int on)
{
	int ret;
	ret = 0;
	switch (on) {
	case STBY_ON:
		sensor_dbg("CSI_SUBDEV_STBY_ON!\n");
		cci_lock(sd);
		vin_gpio_write(sd, PWDN, CSI_GPIO_HIGH);
		vin_set_mclk(sd, OFF);
		cci_unlock(sd);
		break;
	case STBY_OFF:
		sensor_dbg("CSI_SUBDEV_STBY_OFF!\n");
		cci_lock(sd);
		vin_set_mclk_freq(sd, MCLK);
		vin_set_mclk(sd, ON);
		usleep_range(10000, 12000);
		vin_gpio_write(sd, PWDN, CSI_GPIO_LOW);
		usleep_range(10000, 12000);
		cci_unlock(sd);
		ret = sensor_s_sw_stby(sd, CSI_GPIO_LOW);
		if (ret < 0)
			sensor_err("soft stby off falied!\n");
		usleep_range(10000, 12000);
		break;
	case PWR_ON:
		sensor_dbg("CSI_SUBDEV_PWR_ON!\n");
		cci_lock(sd);
		vin_gpio_set_status(sd, PWDN, 1);  /*set the gpio to output */
		vin_gpio_set_status(sd, RESET, 1); /*set the gpio to output */

		vin_gpio_write(sd, RESET, CSI_GPIO_HIGH);
		vin_gpio_write(sd, PWDN, CSI_GPIO_HIGH);
		usleep_range(1000, 1200);
		vin_gpio_write(sd, POWER_EN, CSI_GPIO_HIGH);
		vin_set_pmu_channel(sd, AFVDD, ON); /*1.2V CVDD_12 */
		vin_set_pmu_channel(sd, DVDD, ON);  /*xc7021 VCAM_D 1.5v */
		usleep_range(1000, 1200);
		vin_set_pmu_channel(sd, IOVDD, ON); /*VCAM_IO 1.8v */

		usleep_range(1000, 1200);
		vin_set_pmu_channel(sd, AVDD, ON); /* VCAM_AF 2.8v */
		usleep_range(1000, 1200);

		vin_gpio_write(sd, PWDN, CSI_GPIO_LOW);
		usleep_range(10000, 12000);
		vin_gpio_write(sd, RESET, CSI_GPIO_LOW);
		usleep_range(30000, 32000);
		vin_gpio_write(sd, RESET, CSI_GPIO_HIGH);
		vin_set_mclk_freq(sd, MCLK);
		vin_set_mclk(sd, ON);
		usleep_range(10000, 12000);
		cci_unlock(sd);
		break;

	case PWR_OFF:
		sensor_dbg("CSI_SUBDEV_PWR_OFF!\n");
		cci_lock(sd);
		vin_gpio_write(sd, POWER_EN, CSI_GPIO_LOW);
		vin_gpio_set_status(sd, PWDN, 1);  /*set the gpio to output */
		vin_gpio_set_status(sd, RESET, 1); /*set the gpio to output */
		vin_gpio_write(sd, RESET, CSI_GPIO_LOW);
		vin_gpio_write(sd, PWDN, CSI_GPIO_HIGH);
		vin_set_mclk(sd, OFF);
		vin_set_pmu_channel(sd, AVDD, OFF); /* VCAM_AF 2.8v */
		usleep_range(10000, 12000);
		vin_set_pmu_channel(sd, DVDD, OFF); /*VCAM_D 1.5v */
		usleep_range(10000, 12000);
		vin_set_pmu_channel(sd, IOVDD, OFF); /*VCAM_IO 1.8v */
		vin_set_pmu_channel(sd, AFVDD, OFF); /*1.2V  CVDD_12 */
		vin_gpio_set_status(sd, RESET, 0); /*set the gpio to input */
		vin_gpio_set_status(sd, PWDN, 0);  /*set the gpio to input */
		cci_unlock(sd);
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

static int sensor_reset(struct v4l2_subdev *sd, u32 val)
{
	switch (val) {
	case 0:
		vin_gpio_write(sd, RESET, CSI_GPIO_HIGH);
		usleep_range(10000, 12000);
		break;
	case 1:
		vin_gpio_write(sd, RESET, CSI_GPIO_LOW);
		usleep_range(10000, 12000);
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

static int xc7021_isp_detect(struct v4l2_subdev *sd)
{
	int ret;
	struct regval_list regs;

	regs.addr = 0xfffb;
	ret = sensor_read(sd, regs.addr, &regs.data);
	if (ret < 0) {
		sensor_err("sensor_read err at sensor_detect!\n");
		return ret;
	}
	sensor_dbg("sc2233_xc7021 [0xfffb] chip  ID =0x%x\n ", regs.data);
	if (regs.data != ((V4L2_IDENT_SENSOR >> 8) & 0xff)) {
		sensor_dbg("Read chip  ID err in sc2233_xc7021 [0xfffb]");
		return -1;
	}

	regs.addr = 0xfffc;
	ret = sensor_read(sd, regs.addr, &regs.data);
	if (ret < 0) {
		sensor_err("sensor_read err at sensor_detect!\n");
		return ret;
	}
	sensor_dbg("sc2233_xc7021 [0xfffc] chip  ID =0x%x\n ", regs.data);
	if (regs.data != (V4L2_IDENT_SENSOR & 0xff)) {
		sensor_dbg("Read chip  ID err in sc2233_xc7021 [0xfffc]");
		return -1;
	}

	return 0;
}

static int sc2233_i2c_bypass(struct v4l2_subdev *sd, bool enable)
{
	int ret = -1;

	if (enable > 0) {
		ret = sensor_write_array(sd, bypass_on, ARRAY_SIZE(bypass_on));
		sensor_print("sc2233_i2c_bypass bypass_on\n");
	} else {
		ret = sensor_write_array(sd, bypass_off, ARRAY_SIZE(bypass_off));
		sensor_print("sc2233_i2c_bypass bypass_off\n");
	}

	if (ret < 0) {
		sensor_err("write i2c_bypass %d sensor_default_regs fail!\n", enable);
		return ret;
	}

	return 0;
}

static int sensor_detect(struct v4l2_subdev *sd)
{
	int ret;
	struct regval_list regs;

	sc2233_i2c_bypass(sd, 1);
	regs.addr = 0x3107;
	regs.data = 0x22;
	ret = sensor_read_sc2233(sd, regs.addr, (unsigned char *)&regs.data);
	sensor_dbg("sc2233 chip  ID [0x3107]=0x%x\n ", regs.data);
	if (ret < 0 || (regs.data != ((sc2233_CHIPID >> 8) & 0xff))) {
		sensor_err("sensor_read err at sensor_detect!\n");
		ret = -1;
	}

	regs.addr = 0x3108;
	ret = sensor_read_sc2233(sd, regs.addr , (unsigned char *)&regs.data);
	sensor_dbg("sc2233 chip  ID [0x3108]=0x%x\n ", regs.data);
	if (ret < 0 || (regs.data != (sc2233_CHIPID & 0xff))) {
		sensor_err("sensor_read err at sensor_detect!\n");
		ret = -1;
	}
	sc2233_i2c_bypass(sd, 0);

	return ret;
}

static int sensor_init(struct v4l2_subdev *sd, u32 val)
{
	int ret;
	struct sensor_info *info = to_state(sd);

	sensor_dbg("sensor_init\n");
	/*Make sure it is a target sensor */
	ret = xc7021_isp_detect(sd);
	if (ret) {
		sensor_err("xc7021_isp chip is not an target chip.\n");
		return ret;
	} else
		sensor_print("xc7021_isp chip found is target chip.\n");

	info->focus_status = 0;
	info->low_speed = 0;
	info->width = HD1080_WIDTH;
	info->height = HD1080_HEIGHT;
	info->hflip = 0;
	info->vflip = 0;
	info->gain = 0;

	info->tpf.numerator = 1;
	info->tpf.denominator = SENSOR_FRAME_RATE;

	ret = sensor_write_array(sd, XC7021_default_regs,
			ARRAY_SIZE(XC7021_default_regs));
	if (ret < 0) {
		sensor_err("write sensor_default_regs error\n");
		return ret;
	}
	usleep_range(10000, 10500);

	ret = sensor_detect(sd);
	if (ret) {
		sensor_err("chip found is not an target chip.\n");
		return ret;
	}

	return 0;
}

static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
{
	int ret = 0;
	struct sensor_info *info = to_state(sd);
	switch (cmd) {
	case GET_CURRENT_WIN_CFG:
		if (info->current_wins != NULL) {
			memcpy(arg, info->current_wins,
				sizeof(struct sensor_win_size));
			ret = 0;
		} else {
			sensor_err("empty wins!\n");
			ret = -1;
		}
		break;
	case SET_FPS:
		break;
	case ISP_SET_EXP_GAIN:
		sensor_s_exp_gain(sd, (struct sensor_exp_gain *)arg);
		break;
	default:
		return -EINVAL;
	}

	return ret;
}

static struct sensor_format_struct  sensor_formats[] = {
	{
		.desc       = "YUYV 4:2:2",
		.mbus_code  = V4L2_MBUS_FMT_YUYV8_2X8,
		.regs       = sensor_fmt_yuv422_yuyv,
		.regs_size  = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
		.bpp        = 2,
	},
};
#define N_FMTS ARRAY_SIZE(sensor_formats)

/*
 * Then there is the issue of window sizes.  Try to capture the info here.
 */
static struct sensor_win_size sensor_win_sizes_30fps[] = {
	{
	.width      = HD1080_WIDTH,
	.height     = HD1080_HEIGHT,
	.hoffset    = 0,
	.voffset    = 0,
	.regs       = xc7021_1080p_regs_30fps,
	.regs_size  = ARRAY_SIZE(xc7021_1080p_regs_30fps),
	.set_size   = NULL,
	},
	{
	.width      = HD720_WIDTH,
	.height     = HD720_HEIGHT,
	.hoffset    = 0,
	.voffset    = 0,
	.regs       = xc7021_720p_regs_30fps,
	.regs_size  = ARRAY_SIZE(xc7021_720p_regs_30fps),
	.set_size   = NULL,
	},
	{
	.width      = VGA_WIDTH,
	.height     = VGA_HEIGHT,
	.hoffset    = 0,
	.voffset    = 0,
	.regs       = xc7021_480p_regs_30fps,
	.regs_size  = ARRAY_SIZE(xc7021_480p_regs_30fps),
	.set_size   = NULL,
	},
	/*
	{
	.width      = VGA_WIDTH,
	.height     = 360,
	.hoffset    = 0,
	.voffset    = 0,
	.regs       = xc7021_360p_regs_25fps,
	.regs_size  = ARRAY_SIZE(xc7021_360p_regs_25fps),
	.set_size   = NULL,
	},
	*/
};

static struct sensor_win_size sensor_win_sizes_15fps[] = {
	{
	.width      = HD1080_WIDTH,
	.height     = HD1080_HEIGHT,
	.hoffset    = 0,
	.voffset    = 0,
	.regs       = xc7021_1080p_regs_15fps,
	.regs_size  = ARRAY_SIZE(xc7021_1080p_regs_15fps),
	.set_size   = NULL,
	},
	{
	.width      = HD720_WIDTH,
	.height     = HD720_HEIGHT,
	.hoffset    = 0,
	.voffset    = 0,
	.regs       = xc7021_720p_regs_15fps,
	.regs_size  = ARRAY_SIZE(xc7021_720p_regs_15fps),
	.set_size   = NULL,
	},
	{
	.width      = VGA_WIDTH,
	.height     = VGA_HEIGHT,
	.hoffset    = 0,
	.voffset    = 0,
	.regs       = xc7021_480p_regs_15fps,
	.regs_size  = ARRAY_SIZE(xc7021_480p_regs_15fps),
	.set_size   = NULL,
	},
	/*
	{
	.width      = VGA_WIDTH,
	.height     = 360,
	.hoffset    = 0,
	.voffset    = 0,
	.regs       = xc7021_360p_regs_15fps,
	.regs_size  = ARRAY_SIZE(xc7021_360p_regs_15fps),
	.set_size   = NULL,
	},
	*/
};


#define N_WIN_SIZES_15FPS (ARRAY_SIZE(sensor_win_sizes_15fps))
#define N_WIN_SIZES_25FPS (ARRAY_SIZE(sensor_win_sizes_30fps))

static int sensor_g_mbus_config(struct v4l2_subdev *sd,
				struct v4l2_mbus_config *cfg)
{
	cfg->type = V4L2_MBUS_PARALLEL;
	cfg->flags = V4L2_MBUS_MASTER | VREF_POL | HREF_POL | CLK_POL;

	return 0;
}

static int sensor_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
{
	/* Fill in min, max, step and default value for these controls. */
	/* see include/linux/videodev2.h for details */

	switch (qc->id) {
	case V4L2_CID_GAIN:
		return v4l2_ctrl_query_fill(qc, 1 * 16, 16 * 16, 1, 16);
	case V4L2_CID_EXPOSURE:
		return v4l2_ctrl_query_fill(qc, 1, 65536 * 16, 1, 1);
	case V4L2_CID_FRAME_RATE:
		return v4l2_ctrl_query_fill(qc, 15, 120, 1, 30);
	}
	return -EINVAL;
}

static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
	switch (ctrl->id) {
	case V4L2_CID_GAIN:
		return sensor_g_gain(sd, &ctrl->value);
	case V4L2_CID_EXPOSURE:
		return sensor_g_exp(sd, &ctrl->value);
	}
	return -EINVAL;
}

static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
#if 0
	struct v4l2_queryctrl qc;
	int ret;

	qc.id = ctrl->id;
	ret = sensor_queryctrl(sd, &qc);
	if (ret < 0)
		return ret;

	if (ctrl->value < qc.minimum || ctrl->value > qc.maximum) {
		sensor_err("max gain qurery is %d,min gain qurey is %d\n",
				qc.maximum, qc.minimum);
		return -ERANGE;
	}

	switch (ctrl->id) {
	case V4L2_CID_GAIN:
		return sensor_s_gain(sd, ctrl->value);
	case V4L2_CID_EXPOSURE:
		return sensor_s_exp(sd, ctrl->value);
	}
	return -EINVAL;
#else
	return 0;
#endif
}

static int sensor_g_chip_ident(struct v4l2_subdev *sd,
				struct v4l2_dbg_chip_ident *chip)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);

	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
}

static int sensor_reg_init(struct sensor_info *info)
{
	struct v4l2_subdev *sd = &info->sd;
	struct sensor_format_struct *sensor_fmt = info->fmt;
	struct sensor_win_size *wsize = info->current_wins;
	void __iomem *parser_base;

	sensor_dbg("sensor_reg_init\n");
	sensor_write_array(sd, sensor_fmt->regs, sensor_fmt->regs_size);

	if (wsize->regs)
		sensor_write_array(sd, wsize->regs, wsize->regs_size);
	usleep_range(10000, 10500);

#ifndef DEBUG_COLORBAR
	sensor_detect(sd);
	/*sc2233 initial*/
	sensor_write_array_sc2233(sd, SC2233dvp_default_regs,
				ARRAY_SIZE(SC2233dvp_default_regs));
#endif
	usleep_range(10000, 10500);

	sensor_dbg("delay the pclk to capture stream!\n");
	/* remap parser address to virtual address */
	parser_base = ioremap(0x06621000, 0xf00);
	/* Parser NCSIC RX signal0 delay adjust regester :(parser_base + 0x500) */
	/* 0xb :this value is the result of test */
	writel(0xb, (parser_base + 0x500));

	msleep(50); /* time of ISP prepare */

	return 0;
}

static int sensor_s_stream(struct v4l2_subdev *sd, int enable)
{
	struct sensor_info *info = to_state(sd);
	sensor_print("%s on = %d, %d*%d %x\n", __func__, enable,
				info->current_wins->width,
				info->current_wins->height,
				info->fmt->mbus_code);

	if (!enable)
		return 0;
	return sensor_reg_init(info);
}


/* ----------------------------------------------------------------------- */

static const struct v4l2_subdev_core_ops sensor_core_ops = {
	.g_chip_ident = sensor_g_chip_ident,
	.g_ctrl = sensor_g_ctrl,
	.s_ctrl = sensor_s_ctrl,
	.queryctrl = sensor_queryctrl,
	.reset = sensor_reset,
	.init = sensor_init,
	.s_power = sensor_power,
	.ioctl = sensor_ioctl,
};

static const struct v4l2_subdev_video_ops sensor_video_ops = {
	.s_parm = sensor_s_parm,
	.g_parm = sensor_g_parm,
	.s_stream = sensor_s_stream,
	.g_mbus_config = sensor_g_mbus_config,
};

static const struct v4l2_subdev_pad_ops sensor_pad_ops = {
	.enum_mbus_code = sensor_enum_mbus_code,
	.enum_frame_size = sensor_enum_frame_size,
	.get_fmt = sensor_get_fmt,
	.set_fmt = sensor_set_fmt,
};

static const struct v4l2_subdev_ops sensor_ops = {
	.core = &sensor_core_ops,
	.video = &sensor_video_ops,
	.pad = &sensor_pad_ops,
};

/* ----------------------------------------------------------- */
static struct cci_driver cci_drv = {
	.name = SENSOR_NAME,
	.addr_width = CCI_BITS_16,
	.data_width = CCI_BITS_8,
};

static int sensor_probe(struct i2c_client *client,
				const struct i2c_device_id *id)
{
	struct v4l2_subdev *sd;
	struct sensor_info *info;
	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);

	if (info == NULL)
		return -ENOMEM;
	sd = &info->sd;
	cci_dev_probe_helper(sd, client, &sensor_ops, &cci_drv);
	mutex_init(&info->lock);
	info->fmt = &sensor_formats[0];
	info->fmt_pt = &sensor_formats[0];

	if (info->tpf.denominator == SENSOR_FRAME_RATE_15FPS) {
		info->win_pt = &sensor_win_sizes_15fps[0];
		info->win_size_num = N_WIN_SIZES_15FPS;
	} else {
		info->win_pt = &sensor_win_sizes_30fps[0];
		info->win_size_num = N_WIN_SIZES_25FPS;
	}


	info->fmt_num = N_FMTS;

	info->sensor_field = V4L2_FIELD_NONE;
	info->af_first_flag = 1;
	return 0;
}

static int sensor_remove(struct i2c_client *client)
{
	struct v4l2_subdev *sd;
	sd = cci_dev_remove_helper(client, &cci_drv);
	kfree(to_state(sd));
	return 0;
}

static const struct i2c_device_id sensor_id[] = {
	{SENSOR_NAME, 0},
	{}
};

MODULE_DEVICE_TABLE(i2c, sensor_id);

static struct i2c_driver sensor_driver = {
	.driver = {
		.owner = THIS_MODULE,
		.name = SENSOR_NAME,
		},
	.probe = sensor_probe,
	.remove = sensor_remove,
	.id_table = sensor_id,
};

static __init int init_sensor(void)
{
	return cci_dev_init_helper(&sensor_driver);
}

static __exit void exit_sensor(void)
{
	cci_dev_exit_helper(&sensor_driver);
}

module_init(init_sensor);
module_exit(exit_sensor);
