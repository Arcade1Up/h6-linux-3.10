/* **************************************************************************************
 *f22_xc7021.c
 *A V4L2 driver for f22_AW6131 cameras
 *Copyright (c) 2014 by Allwinnertech Co., Ltd.http://www.allwinnertech.com
 *	Version		Author			Date				Description
 *	1.0			richard.liu		2017/03/01			f22_xc7021 YUV sensor Support
 *	1.1			richard.liu		2017/03/10			optimize sharpness \ AWE\AE
 *	1.2			richard.liu		2017/03/15			optimize sharpness \ AWE\AE 720P & 480P
 *	1.3			richard.liu		2017/03/16			add 640*360
 *	1.4			zhengjiangwei	2017/09/27			adapt vin in H6
 ****************************************************************************************
 */
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/i2c.h>
#include <linux/delay.h>
#include <linux/videodev2.h>
#include <linux/clk.h>
#include <media/v4l2-device.h>
#include <media/v4l2-chip-ident.h>
#include <media/v4l2-mediabus.h>
#include <linux/io.h>
#include "camera.h"

/*static struct delayed_work sensor_s_ae_ratio_work;*/
#define SENSOR_NAME "f22_xc7021"
#include "sensor_helper.h"

MODULE_AUTHOR("jiangwei.zheng");
MODULE_DESCRIPTION("A low-level driver for f22_xc7021 sensors");
MODULE_LICENSE("GPL");

/*define module timing*/
#define MCLK              (24*1000*1000)
#define VREF_POL          V4L2_MBUS_VSYNC_ACTIVE_LOW
#define HREF_POL          V4L2_MBUS_HSYNC_ACTIVE_HIGH
#define CLK_POL           V4L2_MBUS_PCLK_SAMPLE_RISING
#define V4L2_IDENT_SENSOR  0x7021
#define f22_CHIPID      (0x0f)

/*
 * Our nominal (default) frame rate.
 */
#define SENSOR_FRAME_RATE		30
#define SENSOR_FRAME_RATE_15FPS 15

/*
 * The  ISP xc7021 i2c address
 */
#define XC7021_WRITE_ADDR	(0x36)
#define XC7021_READ_ADDR	(0x37)
/*
 * The  f22 sensor i2c address, the f22 i2c address  different XC7021 address
 */
#define I2C_ADDR_f22_SENSOR	(0x80 >> 1)

/*#define DEBUG_COLORBAR       1*/


static int f22_i2c_bypass(struct v4l2_subdev *sd, bool enable);

/*
 * Information we maintain about a known sensor.
 */

static struct regval_list bypass_on[] = {
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x004d, 0x01},
};

static struct regval_list bypass_off[] = {
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x004d, 0x00},
};

static struct regval_list XC7021_default_regs[] = {
	/*30 fps  cofigure*/
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x001c, 0xff},
	{0x001d, 0xff},
	{0x001e, 0xff},
	{0x001f, 0xff},
	{0x0018, 0x00},
	{0x0019, 0x00},
	{0x001a, 0x00},
	{0x001b, 0x00},
	{0x00bc, 0x11},
	{0x00bd, 0x00},
	{0x00be, 0x00},
	{0x00bf, 0x00},

	{0x0030, 0x09},
	{0x0031, 0x02},
	{0x0032, 0x0d},

	{0x0020, 0x01},
	{0x0021, 0x0e},
	{0x0023, 0x02},
	{0x0024, 0x06},
	{0x0025, 0x00},
	{0x0026, 0x01},
	{0x0027, 0x06},
	{0x0028, 0x08},
	{0x0029, 0x06},
	{0x00aa, 0x40},

	{0xfffe, 0x50},
	{0x0200, 0x03},
	{0x0204, 0x03},
	{0x0208, 0x02},
	{0x0208, 0x01},

	{0xfffe, 0x50},
	{0x00bc, 0x11},
	{0x001b, 0x0},
	{0x0090, 0x29},

	{0xfffe, 0x20},
	{0x0000, 0x20},
	{0x0004, 0x7},
	{0x0005, 0x80},
	{0x0006, 0x4},
	{0x0007, 0x38},

	{0xfffe, 0x26},
	{0x4000, 0xF9},
	{0x6001, 0x14},
	{0x6005, 0xc4},
	{0x6006, 0xF},
	{0x6007, 0xA0},
	{0x6008, 0xE},
	{0x6009, 0xFC},

	{0x8000, 0x3f},
	{0x8001, 0x80},
	{0x8002, 0x7},
	{0x8003, 0x38},
	{0x8004, 0x4},
	{0x8005, 0x3},
	{0x8006, 0x5},
	{0x8007, 0x99},
	{0x8008, 0x14},

	{0x8010, 0x4},
	{0x8012, 0x80},
	{0x8013, 0x7},
	{0x8014, 0x38},
	{0x8015, 0x4},
	{0x8016, 0x0},
	{0x8017, 0x0},
	{0x8018, 0x0},
	{0x8019, 0x0},

	{0xfffe, 0x30},
	{0x0001, 0x1},
	{0x0004, 0x18},
	{0x0006, 0x7},
	{0x0007, 0x80},
	{0x0008, 0x4},
	{0x0009, 0x38},
	{0x000a, 0x7},
	{0x000b, 0x80},
	{0x000c, 0x4},
	{0x000d, 0x38},
	{0x0027, 0xF7},
	{0x005e, 0x7},
	{0x005f, 0x7F},
	{0x0060, 0x4},
	{0x0061, 0x37},
	{0x1908, 0x0},
	{0x1900, 0x0},
	{0x1901, 0x0},
	{0x1902, 0x0},
	{0x1903, 0x0},
	{0x1904, 0x7},
	{0x1905, 0x80},
	{0x1906, 0x4},
	{0x1907, 0x38},

	{0xfffe, 0x25},
	{0x0002, 0x80},

	{0xfffe, 0x30},
	{0x1f00, 0x00},
	{0x1f01, 0x00},
	{0x1f02, 0x00},
	{0x1f03, 0x00},
	{0x1f04, 0x05},
	{0x1f05, 0x00},
	{0x1f06, 0x02},
	{0x1f07, 0xd0},

	{0xfffe, 0x14},
	{0x0026, 0x01},
	{0x00be, 0x80},
	{0x00bf, 0x00},
	{0x00c0, 0x06},
	{0x00c1, 0x02},
	{0x00c3, 0x00},

	{0x00c4, 0x00},
	{0x00c5, 0x02},
	{0x00c6, 0x00},
	{0x00c7, 0x01},
	{0x00c8, 0x00},
	{0x00c9, 0x00},
	{0x00cc, 0x00},
	{0x00cd, 0xff},
	{0x00ce, 0x00},
	{0x00cf, 0xff},

	{0x00d0, 0x00},
	{0x00d1, 0x00},
	{0x00d2, 0x00},
	{0x00d3, 0x00},

	{0x00e4, 0x00},
	{0x00e5, 0x00},
	{0x00ec, 0x00},
	{0x00ed, 0xff},
	{0x00ee, 0x00},
	{0x00ef, 0x00},
	{0x00f0, 0x00},
	{0x00f1, 0x00},
	{0x00f2, 0x00},
	{0x00f3, 0x00},

	{0xfffe, 0x14},
	{0x00b4, 0x02},
	{0x00b8, 0x16},
	{0x00b9, 0x80},

	{0xfffe, 0x14},
	{0x0035, 0x01},
	{0x00aa, 0x01},
	{0x00ab, 0x00},
	{0x00ba, 0x00},
	{0x006a, 0x01},

	{0x006b, 0x40},
	{0x006c, 0x02},
	{0x006d, 0x10},
	{0x0073, 0x08},
	{0x0092, 0x3e},
	{0x0093, 0x00},

	{0xfffe, 0x14},
	{0x0039, 0x00},
	{0x0060, 0x00},

	{0x0076, 0x01},
	{0x0079, 0x01},
	{0x007a, 0x00},
	{0x007b, 0x30},
	{0x007c, 0x00},
	{0x007d, 0xc0},
	{0x0077, 0x30},
	{0x0078, 0x01},
	{0x007f, 0x80},
	{0x0087, 0x60},
	{0x0088, 0x02},
	{0x008c, 0x03},
	{0x008d, 0xc0},

	{0xfffe, 0x14},
	{0x3f, 0x10},
	{0x40, 0x10},
	{0x41, 0x10},
	{0x42, 0x10},
	{0x43, 0x10},
	{0x44, 0x10},
	{0x45, 0x10},
	{0x46, 0x10},
	{0x47, 0x10},
	{0x48, 0x10},
	{0x49, 0x10},
	{0x4a, 0x40},
	{0x4b, 0x40},
	{0x4c, 0x40},
	{0x4d, 0x10},
	{0x4e, 0x10},
	{0x4f, 0x40},
	{0x50, 0x40},
	{0x51, 0x40},
	{0x52, 0x10},
	{0x53, 0x10},
	{0x54, 0x10},
	{0x55, 0x10},
	{0x56, 0x10},
	{0x57, 0x10},
	{0x3a, 0x01},

	{0xfffe, 0x14},
	{0x010f, 0x01},
	{0x0110, 0x01},
	{0x0112, 0x03},
	{0x0113, 0x03},
	{0x0114, 0x03},
	{0x011a, 0x00},
	{0x011b, 0x60},
	{0x011c, 0x02},
	{0x011d, 0x80},
	{0x011e, 0x00},
	{0x011f, 0x40},
	{0x0120, 0x02},
	{0x0121, 0xc0},
	{0x0062, 0x00},
	{0x0063, 0x60},
	{0x0064, 0x00},
	{0x0065, 0x40},
	{0x0066, 0x01},
	{0X0067, 0x00},
	{0x0074, 0x20},
	{0x0075, 0x40},
	{0x006e, 0x6},
	{0x006f, 0x1},
	{0x012a, 0x05},
	{0x012b, 0x00},
	{0x012c, 0x00},
	{0x012d, 0x30},

	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x000e, 0x54},
	{0xfffe, 0x14},
	{0x0006, 0x1},
	{0x0007, 0xef},
	{0x0014, 0x00},
	{0x0015, 0x14},
	{0x0016, 0x5},
	{0x0017, 0x8c},
	{0x3e0, 0x9c},
	{0x3e1, 0x21},
	{0x3e2, 0xff},
	{0x3e3, 0xf8},
	{0x3e4, 0xd4},
	{0x3e5, 0x1},
	{0x3e6, 0x48},
	{0x3e8, 0xd4},
	{0x3e9, 0x1},
	{0x3ea, 0x50},
	{0x3eb, 0x4},
	{0x3ec, 0x18},
	{0x3ed, 0x60},
	{0x3ef, 0x14},
	{0x3f0, 0xa8},
	{0x3f1, 0x63},
	{0x3f2, 0x1},
	{0x3f3, 0xd0},
	{0x3f4, 0x19},
	{0x3f5, 0x60},
	{0x3f7, 0x14},
	{0x3f8, 0xa9},
	{0x3f9, 0x6b},
	{0x3fa, 0x3},
	{0x3fb, 0xd4},
	{0x3fc, 0x94},
	{0x3fd, 0xa3},
	{0x400, 0x19},
	{0x401, 0xa0},
	{0x403, 0x14},
	{0x404, 0xa9},
	{0x405, 0xad},
	{0x406, 0x3},
	{0x407, 0xdc},
	{0x408, 0x85},
	{0x409, 0xb},
	{0x40c, 0x18},
	{0x40d, 0x60},
	{0x40f, 0x14},
	{0x410, 0xa8},
	{0x411, 0x63},
	{0x412, 0x2},
	{0x413, 0xb0},
	{0x414, 0xb8},
	{0x415, 0xe5},
	{0x417, 0x44},
	{0x418, 0x85},
	{0x419, 0x43},
	{0x41c, 0x9c},
	{0x41d, 0x80},
	{0x41f, 0x3},
	{0x420, 0x8c},
	{0x421, 0xaa},
	{0x423, 0x3a},
	{0x424, 0x84},
	{0x425, 0x6d},
	{0x428, 0xe0},
	{0x429, 0xe7},
	{0x42a, 0x28},
	{0x42b, 0x2},
	{0x42c, 0x8c},
	{0x42d, 0xca},
	{0x42f, 0x3c},
	{0x430, 0x18},
	{0x431, 0xa0},
	{0x433, 0x14},
	{0x434, 0xa8},
	{0x435, 0xa5},
	{0x436, 0x3},
	{0x437, 0xd8},
	{0x438, 0xd4},
	{0x439, 0xb},
	{0x43a, 0x18},
	{0x43c, 0xe5},
	{0x43d, 0xa6},
	{0x43e, 0x38},
	{0x440, 0x10},
	{0x443, 0x3},
	{0x444, 0xd4},
	{0x445, 0x5},
	{0x446, 0x40},
	{0x448, 0xa8},
	{0x449, 0xc7},
	{0x44c, 0x8c},
	{0x44d, 0xaa},
	{0x44f, 0x3b},
	{0x450, 0xe5},
	{0x451, 0x66},
	{0x452, 0x28},
	{0x454, 0x10},
	{0x457, 0x3},
	{0x458, 0x15},
	{0x45c, 0xa8},
	{0x45d, 0xc5},
	{0x460, 0xe0},
	{0x461, 0x66},
	{0x462, 0x18},
	{0x464, 0xd4},
	{0x465, 0xd},
	{0x466, 0x30},
	{0x468, 0x7},
	{0x469, 0xfb},
	{0x46a, 0x1c},
	{0x46b, 0xd1},
	{0x46c, 0xe0},
	{0x46d, 0x63},
	{0x46e, 0x40},
	{0x470, 0x9c},
	{0x471, 0x60},
	{0x472, 0x1},
	{0x474, 0xdc},
	{0x475, 0xa},
	{0x476, 0x58},
	{0x477, 0xfa},
	{0x478, 0xe0},
	{0x479, 0x83},
	{0x47a, 0x58},
	{0x47b, 0x2},
	{0x47c, 0x18},
	{0x47d, 0xc0},
	{0x47f, 0x14},
	{0x480, 0xa8},
	{0x481, 0xc6},
	{0x482, 0x1},
	{0x483, 0xe0},
	{0x484, 0x94},
	{0x485, 0xa6},
	{0x488, 0x94},
	{0x489, 0x66},
	{0x48b, 0x2},
	{0x48c, 0xe0},
	{0x48d, 0x84},
	{0x48e, 0x2b},
	{0x48f, 0x6},
	{0x490, 0xe1},
	{0x491, 0x63},
	{0x492, 0x5b},
	{0x493, 0x6},
	{0x494, 0xe1},
	{0x495, 0x6b},
	{0x496, 0x20},
	{0x498, 0xb9},
	{0x499, 0x6b},
	{0x49b, 0x48},
	{0x49c, 0xdc},
	{0x49d, 0xa},
	{0x49e, 0x58},
	{0x49f, 0xc4},
	{0x4a0, 0x85},
	{0x4a1, 0x21},
	{0x4a4, 0x85},
	{0x4a5, 0x41},
	{0x4a7, 0x4},
	{0x4a8, 0x44},
	{0x4aa, 0x48},
	{0x4ac, 0x9c},
	{0x4ad, 0x21},
	{0x4af, 0x8},
	{0x4b0, 0x18},
	{0x4b1, 0x80},
	{0x4b3, 0x14},
	{0x4b4, 0xa8},
	{0x4b5, 0x84},
	{0x4b6, 0x2},
	{0x4b7, 0xcc},
	{0x4b8, 0x84},
	{0x4b9, 0x64},
	{0x4bc, 0xbc},
	{0x4bd, 0x23},
	{0x4bf, 0x41},
	{0x4c0, 0xc},
	{0x4c3, 0x6},
	{0x4c4, 0xbc},
	{0x4c5, 0x23},
	{0x4c7, 0x3f},
	{0x4c8, 0x10},
	{0x4cb, 0x6},
	{0x4cc, 0x9c},
	{0x4cd, 0x60},
	{0x4cf, 0x3e},
	{0x4d3, 0x4},
	{0x4d4, 0xd4},
	{0x4d5, 0x4},
	{0x4d6, 0x18},
	{0x4d8, 0x9c},
	{0x4d9, 0x60},
	{0x4db, 0x42},
	{0x4dc, 0xd4},
	{0x4dd, 0x4},
	{0x4de, 0x18},
	{0x4e0, 0x44},
	{0x4e2, 0x48},
	{0x4e4, 0x15},
	{0x4e8, 0x9c},
	{0x4e9, 0x21},
	{0x4ea, 0xff},
	{0x4eb, 0xfc},
	{0x4ec, 0xd4},
	{0x4ed, 0x1},
	{0x4ee, 0x48},
	{0x4f0, 0x19},
	{0x4f1, 0xa0},
	{0x4f3, 0x14},
	{0x4f4, 0xa9},
	{0x4f5, 0xad},
	{0x4f6, 0x2},
	{0x4f7, 0xb0},
	{0x4f8, 0x9d},
	{0x4f9, 0x60},
	{0x4fc, 0x84},
	{0x4fd, 0x6d},
	{0x500, 0x84},
	{0x501, 0x63},
	{0x503, 0xd0},
	{0x504, 0xb8},
	{0x505, 0x83},
	{0x507, 0x41},
	{0x50b, 0x4},
	{0x50c, 0xb8},
	{0x50d, 0xc3},
	{0x50f, 0x45},
	{0x510, 0xb8},
	{0x511, 0xc6},
	{0x513, 0x41},
	{0x514, 0xa5},
	{0x515, 0x63},
	{0x516, 0xff},
	{0x517, 0xff},
	{0x518, 0xbc},
	{0x519, 0xa6},
	{0x51b, 0x1},
	{0x51c, 0xf},
	{0x51d, 0xff},
	{0x51e, 0xff},
	{0x51f, 0xfd},
	{0x520, 0x9c},
	{0x521, 0x6b},
	{0x523, 0x1},
	{0x524, 0xe0},
	{0x525, 0x64},
	{0x526, 0x58},
	{0x527, 0x48},
	{0x528, 0x9c},
	{0x529, 0x63},
	{0x52a, 0xff},
	{0x52b, 0xf0},
	{0x52c, 0xbc},
	{0x52d, 0x3},
	{0x530, 0x10},
	{0x533, 0xa},
	{0x534, 0xa8},
	{0x535, 0xe3},
	{0x538, 0x84},
	{0x539, 0x6d},
	{0x53c, 0x94},
	{0x53d, 0x63},
	{0x53f, 0xfc},
	{0x540, 0xe0},
	{0x541, 0x63},
	{0x542, 0x38},
	{0x544, 0xbc},
	{0x545, 0xa3},
	{0x547, 0xf},
	{0x548, 0x10},
	{0x54b, 0x4},
	{0x54c, 0xa8},
	{0x54d, 0xe3},
	{0x550, 0x9c},
	{0x551, 0x60},
	{0x553, 0xf},
	{0x554, 0xa8},
	{0x555, 0xe3},
	{0x558, 0x9c},
	{0x559, 0x60},
	{0x55b, 0x1},
	{0x55c, 0x84},
	{0x55d, 0x8d},
	{0x560, 0xe0},
	{0x561, 0x63},
	{0x562, 0x58},
	{0x563, 0x8},
	{0x564, 0x8c},
	{0x565, 0xa4},
	{0x567, 0x8b},
	{0x568, 0x9d},
	{0x569, 0x3},
	{0x56a, 0xff},
	{0x56b, 0xff},
	{0x56c, 0x94},
	{0x56d, 0x64},
	{0x56f, 0xb0},
	{0x570, 0xb8},
	{0x571, 0xc8},
	{0x573, 0x4},
	{0x574, 0xe0},
	{0x575, 0x86},
	{0x576, 0x38},
	{0x578, 0x7},
	{0x579, 0xfb},
	{0x57a, 0x19},
	{0x57b, 0xb7},
	{0x57c, 0xa4},
	{0x57d, 0x84},
	{0x57f, 0xff},
	{0x580, 0x85},
	{0x581, 0x21},
	{0x584, 0x44},
	{0x586, 0x48},
	{0x588, 0x9c},
	{0x589, 0x21},
	{0x58b, 0x4},
	{0x58c, 0x9c},
	{0x58d, 0x21},
	{0x58e, 0xff},
	{0x58f, 0xf4},
	{0x590, 0xd4},
	{0x591, 0x1},
	{0x592, 0x48},
	{0x594, 0xd4},
	{0x595, 0x1},
	{0x596, 0x50},
	{0x597, 0x4},
	{0x598, 0xd4},
	{0x599, 0x1},
	{0x59a, 0x60},
	{0x59b, 0x8},
	{0x59c, 0xbc},
	{0x59d, 0x3},
	{0x59e, 0x1},
	{0x59f, 0xc},
	{0x5a0, 0x10},
	{0x5a3, 0x15},
	{0x5a4, 0xbc},
	{0x5a5, 0x43},
	{0x5a6, 0x1},
	{0x5a7, 0xc},
	{0x5a8, 0xc},
	{0x5ab, 0xb},
	{0x5ac, 0xbc},
	{0x5ad, 0x3},
	{0x5ae, 0x1},
	{0x5af, 0x5},
	{0x5b0, 0xbc},
	{0x5b1, 0x3},
	{0x5b2, 0x1},
	{0x5b3, 0x10},
	{0x5b4, 0x10},
	{0x5b7, 0x16},
	{0x5b8, 0xbc},
	{0x5b9, 0x3},
	{0x5ba, 0x4},
	{0x5bb, 0xc},
	{0x5bc, 0x19},
	{0x5bd, 0x80},
	{0x5bf, 0x14},
	{0x5c0, 0xa9},
	{0x5c1, 0x8c},
	{0x5c2, 0x3},
	{0x5c3, 0x18},
	{0x5c4, 0xc},
	{0x5c7, 0x29},
	{0x5c8, 0x15},
	{0x5cf, 0x25},
	{0x5d0, 0x15},
	{0x5d4, 0x19},
	{0x5d5, 0x80},
	{0x5d7, 0x14},
	{0x5d8, 0xa9},
	{0x5d9, 0x8c},
	{0x5da, 0x3},
	{0x5db, 0x18},
	{0x5dc, 0xc},
	{0x5df, 0x23},
	{0x5e0, 0x15},
	{0x5e4, 0x7},
	{0x5e5, 0xff},
	{0x5e6, 0xff},
	{0x5e7, 0x7f},
	{0x5e8, 0x15},
	{0x5ef, 0x20},
	{0x5f0, 0x84},
	{0x5f1, 0x6c},
	{0x5f4, 0x19},
	{0x5f5, 0x80},
	{0x5f7, 0x14},
	{0x5f8, 0xa9},
	{0x5f9, 0x8c},
	{0x5fa, 0x3},
	{0x5fb, 0x18},
	{0x5fc, 0x7},
	{0x5fd, 0xff},
	{0x5fe, 0xff},
	{0x5ff, 0xad},
	{0x600, 0x15},
	{0x607, 0x1a},
	{0x608, 0x84},
	{0x609, 0x6c},
	{0x60c, 0x18},
	{0x60d, 0x60},
	{0x60f, 0x14},
	{0x610, 0xa8},
	{0x611, 0x63},
	{0x612, 0x2},
	{0x613, 0xb0},
	{0x614, 0x19},
	{0x615, 0x40},
	{0x617, 0x14},
	{0x618, 0xa9},
	{0x619, 0x4a},
	{0x61a, 0x2},
	{0x61b, 0xf8},
	{0x61c, 0x84},
	{0x61d, 0x83},
	{0x620, 0x84},
	{0x621, 0xaa},
	{0x624, 0x94},
	{0x625, 0x64},
	{0x627, 0x7e},
	{0x628, 0xe4},
	{0x629, 0xa3},
	{0x62a, 0x28},
	{0x62c, 0x10},
	{0x62f, 0x4},
	{0x630, 0x15},
	{0x634, 0x9c},
	{0x635, 0x60},
	{0x637, 0x4},
	{0x638, 0xd8},
	{0x639, 0x4},
	{0x63a, 0x18},
	{0x63b, 0xd7},
	{0x63c, 0x19},
	{0x63d, 0x80},
	{0x63f, 0x14},
	{0x640, 0xa9},
	{0x641, 0x8c},
	{0x642, 0x3},
	{0x643, 0x18},
	{0x644, 0x84},
	{0x645, 0x6c},
	{0x648, 0x7},
	{0x649, 0xfb},
	{0x64a, 0x5},
	{0x64b, 0xf8},
	{0x64c, 0x84},
	{0x64d, 0x63},
	{0x64e, 0x1},
	{0x64f, 0xc0},
	{0x650, 0x9c},
	{0x651, 0x80},
	{0x652, 0xff},
	{0x653, 0xf0},
	{0x654, 0xe1},
	{0x655, 0x6b},
	{0x656, 0x20},
	{0x657, 0x3},
	{0x65b, 0x4},
	{0x65c, 0xd4},
	{0x65d, 0xa},
	{0x65e, 0x58},
	{0x660, 0x7},
	{0x661, 0xff},
	{0x662, 0xff},
	{0x663, 0xa2},
	{0x664, 0x15},
	{0x668, 0x84},
	{0x669, 0x6c},
	{0x66c, 0x9d},
	{0x66d, 0x60},
	{0x670, 0xd4},
	{0x671, 0x3},
	{0x672, 0x59},
	{0x673, 0xcc},
	{0x674, 0xd4},
	{0x675, 0x3},
	{0x676, 0x59},
	{0x677, 0xc0},
	{0x678, 0xd4},
	{0x679, 0x3},
	{0x67a, 0x59},
	{0x67b, 0xc4},
	{0x67c, 0xd4},
	{0x67d, 0x3},
	{0x67e, 0x59},
	{0x67f, 0xc8},
	{0x680, 0x85},
	{0x681, 0x21},
	{0x684, 0x85},
	{0x685, 0x41},
	{0x687, 0x4},
	{0x688, 0x85},
	{0x689, 0x81},
	{0x68b, 0x8},
	{0x68c, 0x44},
	{0x68e, 0x48},
	{0x690, 0x9c},
	{0x691, 0x21},
	{0x693, 0xc},

	{0x06e, 0x30},
	{0x06f, 0x20},
	{0x070, 0xc0},

	{0xfffe, 0x30},
	{0x0051, 0x03},

	{0xfffe, 0x50},
	{0x0137, 0x99},
	{0xfffe, 0x14},

	{0xfffe, 0x30},
	{0x0200, 0x25},
	{0x0201, 0x19},
	{0x0202, 0x14},
	{0x0203, 0x14},
	{0x0204, 0x1a},
	{0x0205, 0x27},
	{0x0206, 0xa},
	{0x0207, 0x5},
	{0x0208, 0x3},
	{0x0209, 0x4},
	{0x020a, 0x5},
	{0x020b, 0xb},
	{0x020c, 0x4},
	{0x020d, 0x1},
	{0x020e, 0x0},
	{0x020f, 0x0},
	{0x0210, 0x2},
	{0x0211, 0x4},
	{0x0212, 0x4},
	{0x0213, 0x2},
	{0x0214, 0x0},
	{0x0215, 0x0},
	{0x0216, 0x2},
	{0x0217, 0x5},
	{0x0218, 0xc},
	{0x0219, 0x6},
	{0x021a, 0x5},
	{0x021b, 0x5},
	{0x021c, 0x7},
	{0x021d, 0xd},
	{0x021e, 0x31},
	{0x021f, 0x20},
	{0x0220, 0x1a},
	{0x0221, 0x1a},
	{0x0222, 0x21},
	{0x0223, 0x33},
	{0x0224, 0x1},
	{0x0225, 0x23},
	{0x0226, 0x23},
	{0x0227, 0x23},
	{0x0228, 0x11},
	{0x022a, 0x43},
	{0x022b, 0x52},
	{0x022c, 0x52},
	{0x022d, 0x53},
	{0x022e, 0x43},
	{0x0230, 0x52},
	{0x0231, 0x52},
	{0x0232, 0x52},
	{0x0233, 0x52},
	{0x0234, 0x52},
	{0x0236, 0x43},
	{0x0237, 0x53},
	{0x0238, 0x52},
	{0x0239, 0x53},
	{0x023a, 0x53},
	{0x023c, 0x0},
	{0x023d, 0x23},
	{0x023e, 0x23},
	{0x023f, 0x23},
	{0x0240, 0x11},
	{0x0248, 0xbe},

	{0xfffe, 0x30},
	{0x024d, 0x0},
	{0x024e, 0xCC},
	{0x024f, 0x1},
	{0x250, 0x6C},
	{0x251, 0x1},
	{0x252, 0x11},
	{0x253, 0x0},
	{0x254, 0xF2},

	{0xfffd, 0x80},
	{0xfffe, 0x30},
	{0x0000, 0x81},
	{0x0013, 0x01},
	{0x019c, 0x00},

	{0xfffe, 0x14},
	{0x0027, 0x01},
	{0x013c, 0x02},
	{0x0176, 0x06},
	{0x0177, 0x00},
	{0x017a, 0x04},
	{0x017b, 0x00},
	{0x017e, 0x04},
	{0x017f, 0x00},
	{0x0182, 0x04},
	{0x0183, 0x04},
	{0x01aa, 0x06},
	{0x01ab, 0x00},
	{0x01ae, 0x04},
	{0x01af, 0x00},
	{0x01b2, 0x04},
	{0x01b3, 0x04},

	{0xfffe, 0x14},
	{0x0027, 0x01},
	{0x013c, 0x01},
	{0x013d, 0x01},
	{0x013e, 0x00},
	{0x0146, 0x00},

	{0x0170, 0x0f},
	{0x0171, 0xff},

	{0xfffe, 0x30},
	{0x0708, 0x03},
	{0x0709, 0xf0},
	{0x070a, 0x00},
	{0x070b, 0x0c},
	{0x0051, 0x03},
	{0x0096, 0x83},
	{0x0019, 0x48},
	{0x071c, 0x0a},

	{0xfffe, 0x14},
	{0x016e, 0x00},
	{0x016f, 0x08},

	{0xfffd, 0x80},
	{0xfffe, 0x30},
	{0x0000, 0xc7},
	{0x0001, 0x23},
	{0x0003, 0xe5},

	{0x0730, 0x82},
	{0x0731, 0xa0},
	{0x0732, 0x3c},
	{0x0733, 0x48},
	{0x0734, 0x74},
	{0x0735, 0x8d},
	{0x0736, 0x56},
	{0x0737, 0x64},
	{0x0738, 0x56},
	{0x0739, 0x68},
	{0x073a, 0x64},
	{0x073b, 0x78},
	{0x073c, 0x6a},
	{0x073d, 0x96},
	{0x073e, 0x48},
	{0x073f, 0x56},
	{0x0740, 0x60},
	{0x0741, 0x76},
	{0x0742, 0x60},
	{0x0743, 0x7a},
	{0x0744, 0x00},
	{0x0745, 0x00},
	{0x0746, 0x00},
	{0x0747, 0x00},
	{0x0748, 0x00},
	{0x0749, 0x00},
	{0x074a, 0x00},
	{0x074b, 0x00},
	{0x074c, 0x00},
	{0x074d, 0x00},
	{0x074e, 0x00},
	{0x074f, 0x00},
	{0x0750, 0x00},
	{0x0751, 0x00},
	{0x0752, 0x00},
	{0x0753, 0x00},
	{0x0754, 0x00},
	{0x0755, 0x00},
	{0x0756, 0x00},
	{0x0757, 0x00},
	{0x0758, 0x00},
	{0x0759, 0x00},
	{0x075a, 0x00},
	{0x075b, 0x00},
	{0x075c, 0x00},
	{0x075d, 0x00},
	{0x075e, 0x00},
	{0x075f, 0x00},
	{0x0760, 0x00},
	{0x0761, 0x00},
	{0x0762, 0x00},
	{0x0763, 0x00},
	{0x0764, 0x00},
	{0x0765, 0x00},
	{0x0766, 0x00},
	{0x0767, 0x00},
	{0x0768, 0x00},
	{0x0769, 0x00},
	{0x076a, 0x00},
	{0x076b, 0x00},
	{0x076c, 0x00},
	{0x076d, 0x00},
	{0x076e, 0x00},
	{0x076f, 0x00},
	{0x0770, 0x22},
	{0x0771, 0x21},
	{0x0772, 0x10},
	{0x0773, 0x00},
	{0x0774, 0x00},
	{0x0775, 0x00},
	{0x0776, 0x00},
	{0x0777, 0x00},

	{0xfffd, 0x80},
	{0xfffe, 0x30},
	{0x1400, 0x00},
	{0x1401, 0x05},
	{0x1402, 0x0a},
	{0x1403, 0x0f},
	{0x1404, 0x15},
	{0x1405, 0x1a},
	{0x1406, 0x1f},
	{0x1407, 0x24},
	{0x1408, 0x29},
	{0x1409, 0x2e},
	{0x140a, 0x32},
	{0x140b, 0x37},
	{0x140c, 0x3c},
	{0x140d, 0x40},
	{0x140e, 0x45},
	{0x140f, 0x49},
	{0x1410, 0x4e},
	{0x1411, 0x52},
	{0x1412, 0x56},
	{0x1413, 0x5a},
	{0x1414, 0x5e},
	{0x1415, 0x62},
	{0x1416, 0x65},
	{0x1417, 0x69},
	{0x1418, 0x6c},
	{0x1419, 0x6f},
	{0x141a, 0x73},
	{0x141b, 0x76},
	{0x141c, 0x79},
	{0x141d, 0x7c},
	{0x141e, 0x7e},
	{0x141f, 0x81},
	{0x1420, 0x84},
	{0x1421, 0x89},
	{0x1422, 0x8d},
	{0x1423, 0x92},
	{0x1424, 0x96},
	{0x1425, 0x9a},
	{0x1426, 0x9d},
	{0x1427, 0xa1},
	{0x1428, 0xa4},
	{0x1429, 0xa7},
	{0x142a, 0xaa},
	{0x142b, 0xad},
	{0x142c, 0xaf},
	{0x142d, 0xb2},
	{0x142e, 0xb4},
	{0x142f, 0xb6},
	{0x1430, 0xb8},
	{0x1431, 0xbc},
	{0x1432, 0xc0},
	{0x1433, 0xc4},
	{0x1434, 0xc8},
	{0x1435, 0xcc},
	{0x1436, 0xd0},
	{0x1437, 0xd4},
	{0x1438, 0xd8},
	{0x1439, 0xdd},
	{0x143a, 0xe1},
	{0x143b, 0xe6},
	{0x143c, 0xeb},
	{0x143d, 0xf0},
	{0x143e, 0xf5},
	{0x143f, 0xfa},
	{0x1440, 0xff},

	{0xfffe, 0x30},
	{0x2000, 0x3f},
	{0x2001, 0x00},
	{0x2002, 0x04},
	{0x2003, 0x02},
	{0x2004, 0x01},
	{0x2005, 0x01},
	{0x2006, 0x02},
	{0x2007, 0x03},
	{0x2008, 0x04},
	{0x2009, 0x05},
	{0x200a, 0x06},
	{0x200b, 0x1f},

	{0x1908, 0x01},

	{0xfffe, 0x30},
	{0x0e00, 0x14},
	{0x0e01, 0x08},
	{0x0e02, 0x0f},
	{0x0e03, 0x14},
	{0x0e04, 0x24},
	{0x0e05, 0x34},
	{0x0e06, 0x38},
	{0x0e07, 0x38},
	{0x0e08, 0x38},
	{0x0e09, 0x3f},
	{0x0e0a, 0x06},
	{0x0e0b, 0x00},

	{0xfffe, 0x30},
	{0x130e, 0x09},
	{0x130f, 0x0d},

	{0xfffe, 0x30},
	{0x0f00, 0xff},
	{0x0f01, 0x00},
	{0x0f02, 0x00},
	{0x0f03, 0x00},
	{0x0f04, 0x00},
	{0x0f05, 0x00},
	{0x0f06, 0x00},
	{0x0f07, 0x00},
	{0x0f08, 0x00},
	{0x0f09, 0x00},
	{0x0f0a, 0x00},
	{0x0f0b, 0x00},
	{0x0f0c, 0x00},
	{0x0f0d, 0x00},
	{0x0f0e, 0x00},
	{0x0f0f, 0x00},

	{0xfffe, 0x14},
	{0x0160, 0x00},
	{0x0162, 0xb0},
	{0x0163, 0xb0},
	{0x0164, 0x30},
	{0x0165, 0x2c},
	{0x0166, 0x28},
	{0x0167, 0x24},
	{0x0168, 0x44},
	{0x0169, 0x3c},
	{0x016a, 0x34},
	{0x016b, 0x30},
	{0x016c, 0x2c},
	{0x016d, 0x28},

	{0xfffe, 0x14},
	{0x0026, 0x01},
	{0x0027, 0x01},
	{0xfffe, 0x30},
	{0x0000, 0xcf},
	{0x0001, 0x81},
	{0x0003, 0xe5},
	{0x0013, 0x18},
	{0x071c, 0x0a},
	{0x1700, 0x09},
	{0x1701, 0x70},
	{0x1702, 0x76},
	{0x1704, 0x2a},
};

static struct regval_list xc7021_1080p_regs_30fps[] = { /* 1980x1080@30fps */
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0032, 0x0d},
	{0x0025, 0x06},

	{0xfffe, 0x50},
	{0x00bc, 0x11},
	{0x001b, 0x0},
	{0x0090, 0x29},

	{0xfffe, 0x20},
	{0x0000, 0x20},
	{0x0004, 0x7},
	{0x0005, 0x80},
	{0x0006, 0x4},
	{0x0007, 0x38},

	{0xfffe, 0x26},
	{0x4000, 0xF9},
	{0x6001, 0x14},
	{0x6005, 0xc4},
	{0x6006, 0xF},
	{0x6007, 0xA0},
	{0x6008, 0xE},
	{0x6009, 0xFC},

	{0x8000, 0x3f},
	{0x8001, 0x80},
	{0x8002, 0x7},
	{0x8003, 0x38},
	{0x8004, 0x4},
	{0x8005, 0x3},
	{0x8006, 0x5},
	{0x8007, 0x99},
	{0x8008, 0x14},

	{0x8010, 0x4},
	{0x8012, 0x80},
	{0x8013, 0x7},
	{0x8014, 0x38},
	{0x8015, 0x4},
	{0x8016, 0x0},
	{0x8017, 0x0},
	{0x8018, 0x0},
	{0x8019, 0x0},

	{0xfffe, 0x30},
	{0x0001, 0x1},
	{0x0004, 0x18},
	{0x0006, 0x7},
	{0x0007, 0x80},
	{0x0008, 0x4},
	{0x0009, 0x38},
	{0x000a, 0x7},
	{0x000b, 0x80},
	{0x000c, 0x4},
	{0x000d, 0x38},
	{0x0027, 0xF7},
	{0x005e, 0x7},
	{0x005f, 0x7F},
	{0x0060, 0x4},
	{0x0061, 0x37},
	{0x1908, 0x0},
	{0x1900, 0x0},
	{0x1901, 0x0},
	{0x1902, 0x0},
	{0x1903, 0x0},
	{0x1904, 0x7},
	{0x1905, 0x80},
	{0x1906, 0x4},
	{0x1907, 0x38},

	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0004, 0x00},
	{0xfffd, 0x80},
	{0xfffe, 0x14},
	{0x1300, 0x03},
	{0x1301, 0x10},
	{0x1302, 0x32},
	{0x1303, 0x20},
	{0x1304, 0xb0},
	{0x1305, 0x21},
	{0x1306, 0x04},


	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0007, 0x80},
	{0x000d, 0x30},
	{0x0009, 0x00},
	{0x00c4, 0x10},
	{0x00c0, 0x01},
};

static struct regval_list xc7021_720p_regs_30fps[] = {

	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0032, 0x0d},
	{0x0025, 0x06},

	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x00bc, 0x11},
	{0x001b, 0x0},
	{0x0090, 0x29},

	{0xfffe, 0x20},
	{0x0000, 0x20},
	{0x0004, 0x7},
	{0x0005, 0x80},
	{0x0006, 0x4},
	{0x0007, 0x38},

	{0xfffe, 0x26},
	{0x4000, 0xF9},
	{0x6001, 0x14},
	{0x6005, 0xc4},
	{0x6006, 0xA},
	{0x6007, 0x8C},
	{0x6008, 0x9},
	{0x6009, 0xFC},

	{0x8000, 0x3f},
	{0x8001, 0x80},
	{0x8002, 0x7},
	{0x8003, 0x38},
	{0x8004, 0x4},
	{0x8005, 0x3},
	{0x8006, 0x5},
	{0x8007, 0x99},
	{0x8008, 0x14},

	{0x8010, 0x4},
	{0x8012, 0x80},
	{0x8013, 0x7},
	{0x8014, 0x38},
	{0x8015, 0x4},
	{0x8016, 0x0},
	{0x8017, 0x0},
	{0x8018, 0x0},
	{0x8019, 0x0},

	{0xfffe, 0x30},
	{0x0001, 0x19},
	{0x0004, 0x18},
	{0x0006, 0x7},
	{0x0007, 0x80},
	{0x0008, 0x4},
	{0x0009, 0x38},
	{0x000a, 0x5},
	{0x000b, 0x0},
	{0x000c, 0x2},
	{0x000d, 0xD0},
	{0x0027, 0xF1},
	{0x005e, 0x7},
	{0x005f, 0x7F},
	{0x0060, 0x4},
	{0x0061, 0x37},
	{0x1908, 0x1},
	{0x1900, 0x0},
	{0x1901, 0x0},
	{0x1902, 0x0},
	{0x1903, 0x0},
	{0x1904, 0x7},
	{0x1905, 0x80},
	{0x1906, 0x4},
	{0x1907, 0x3A},

	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0004, 0x00},
	{0xfffd, 0x80},
	{0xfffe, 0x14},
	{0x1300, 0x03},
	{0x1301, 0x10},
	{0x1302, 0x32},
	{0x1303, 0x20},
	{0x1304, 0xb0},
	{0x1305, 0x21},
	{0x1306, 0x04},


	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0007, 0x80},
	{0x000d, 0x30},
	{0x0009, 0x00},
	{0x00c4, 0x10},
	{0x00c0, 0x01},
};

static struct regval_list  xc7021_480p_regs_30fps[] = {
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0032, 0x0d},
	{0x0025, 0x06},

	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x00bc, 0x11},
	{0x001b, 0x0},
	{0x0090, 0x29},

	{0xfffe, 0x20},
	{0x0000, 0x20},
	{0x0004, 0x7},
	{0x0005, 0x80},
	{0x0006, 0x4},
	{0x0007, 0x38},

	{0xfffe, 0x26},
	{0x4000, 0xF9},
	{0x6001, 0x14},
	{0x6005, 0xc4},
	{0x6006, 0x5},
	{0x6007, 0x78},
	{0x6008, 0x4},
	{0x6009, 0xFC},

	{0x8000, 0x3f},
	{0x8001, 0x80},
	{0x8002, 0x7},
	{0x8003, 0x38},
	{0x8004, 0x4},
	{0x8005, 0x3},
	{0x8006, 0x5},
	{0x8007, 0x99},
	{0x8008, 0x14},

	{0x8010, 0x4},
	{0x8012, 0x80},
	{0x8013, 0x7},
	{0x8014, 0x38},
	{0x8015, 0x4},
	{0x8016, 0x0},
	{0x8017, 0x0},
	{0x8018, 0x0},
	{0x8019, 0x0},

	{0xfffe, 0x30},
	{0x0001, 0x19},
	{0x0004, 0x18},
	{0x0006, 0x7},
	{0x0007, 0x80},
	{0x0008, 0x4},
	{0x0009, 0x38},
	{0x000a, 0x2},
	{0x000b, 0x80},
	{0x000c, 0x1},
	{0x000d, 0xE0},
	{0x0027, 0xF1},
	{0x005e, 0x7},
	{0x005f, 0x7F},
	{0x0060, 0x4},
	{0x0061, 0x37},
	{0x1908, 0x1},
	{0x1900, 0x0},
	{0x1901, 0xF0},
	{0x1902, 0x0},
	{0x1903, 0x0},
	{0x1904, 0x5},
	{0x1905, 0xA0},
	{0x1906, 0x4},
	{0x1907, 0x3A},

	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0004, 0x00},
	{0xfffd, 0x80},
	{0xfffe, 0x14},
	{0x1300, 0x03},
	{0x1301, 0x10},
	{0x1302, 0x32},
	{0x1303, 0x20},
	{0x1304, 0xb0},
	{0x1305, 0x21},
	{0x1306, 0x04},


	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0007, 0x80},
	{0x000d, 0x30},
	{0x0009, 0x00},
	{0x00c4, 0x10},
	{0x00c0, 0x01},
};

static struct regval_list xc7021_1080p_regs_15fps[] = {

	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0032, 0x09},
	{0x0025, 0x00},

	{0xfffe, 0x50},
	{0x00bc, 0x11},
	{0x001b, 0x0},
	{0x0090, 0x29},

	{0xfffe, 0x20},
	{0x0000, 0x20},
	{0x0004, 0x7},
	{0x0005, 0x80},
	{0x0006, 0x4},
	{0x0007, 0x38},

	{0xfffe, 0x26},
	{0x4000, 0xF9},
	{0x6001, 0x14},
	{0x6005, 0xc4},
	{0x6006, 0xF},
	{0x6007, 0xA0},
	{0x6008, 0xE},
	{0x6009, 0xFC},

	{0x8000, 0x3f},
	{0x8001, 0x80},
	{0x8002, 0x7},
	{0x8003, 0x38},
	{0x8004, 0x4},
	{0x8005, 0x3},
	{0x8006, 0x5},
	{0x8007, 0x99},
	{0x8008, 0x14},

	{0x8010, 0x4},
	{0x8012, 0x80},
	{0x8013, 0x7},
	{0x8014, 0x38},
	{0x8015, 0x4},
	{0x8016, 0x0},
	{0x8017, 0x0},
	{0x8018, 0x0},
	{0x8019, 0x0},

	{0xfffe, 0x30},
	{0x0001, 0x1},
	{0x0004, 0x18},
	{0x0006, 0x7},
	{0x0007, 0x80},
	{0x0008, 0x4},
	{0x0009, 0x38},
	{0x000a, 0x7},
	{0x000b, 0x80},
	{0x000c, 0x4},
	{0x000d, 0x38},
	{0x0027, 0xF7},
	{0x005e, 0x7},
	{0x005f, 0x7F},
	{0x0060, 0x4},
	{0x0061, 0x37},
	{0x1908, 0x0},
	{0x1900, 0x0},
	{0x1901, 0x0},
	{0x1902, 0x0},
	{0x1903, 0x0},
	{0x1904, 0x7},
	{0x1905, 0x80},
	{0x1906, 0x4},
	{0x1907, 0x38},

	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0004, 0x00},
	{0xfffd, 0x80},
	{0xfffe, 0x14},
	{0x1300, 0x03},
	{0x1301, 0x10},
	{0x1302, 0x22},
	{0x1303, 0x20},
	{0x1304, 0xe0},
	{0x1305, 0x21},
	{0x1306, 0x05},


	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0007, 0x80},
	{0x000d, 0x30},
	{0x0009, 0x00},
	{0x00c4, 0x10},
	{0x00c0, 0x01},
};

static struct regval_list xc7021_720p_regs_15fps[] = {
	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0032, 0x09},
	{0x0025, 0x00},

	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x00bc, 0x11},
	{0x001b, 0x0},
	{0x0090, 0x29},

	{0xfffe, 0x20},
	{0x0000, 0x20},
	{0x0004, 0x7},
	{0x0005, 0x80},
	{0x0006, 0x4},
	{0x0007, 0x38},

	{0xfffe, 0x26},
	{0x4000, 0xF9},
	{0x6001, 0x14},
	{0x6005, 0xc4},
	{0x6006, 0xA},
	{0x6007, 0x8C},
	{0x6008, 0x9},
	{0x6009, 0xFC},

	{0x8000, 0x3f},
	{0x8001, 0x80},
	{0x8002, 0x7},
	{0x8003, 0x38},
	{0x8004, 0x4},
	{0x8005, 0x3},
	{0x8006, 0x5},
	{0x8007, 0x99},
	{0x8008, 0x14},

	{0x8010, 0x4},
	{0x8012, 0x80},
	{0x8013, 0x7},
	{0x8014, 0x38},
	{0x8015, 0x4},
	{0x8016, 0x0},
	{0x8017, 0x0},
	{0x8018, 0x0},
	{0x8019, 0x0},

	{0xfffe, 0x30},
	{0x0001, 0x19},
	{0x0004, 0x18},
	{0x0006, 0x7},
	{0x0007, 0x80},
	{0x0008, 0x4},
	{0x0009, 0x38},
	{0x000a, 0x5},
	{0x000b, 0x0},
	{0x000c, 0x2},
	{0x000d, 0xD0},
	{0x0027, 0xF1},
	{0x005e, 0x7},
	{0x005f, 0x7F},
	{0x0060, 0x4},
	{0x0061, 0x37},
	{0x1908, 0x1},
	{0x1900, 0x0},
	{0x1901, 0x0},
	{0x1902, 0x0},
	{0x1903, 0x0},
	{0x1904, 0x7},
	{0x1905, 0x80},
	{0x1906, 0x4},
	{0x1907, 0x3A},

	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0004, 0x00},
	{0xfffd, 0x80},
	{0xfffe, 0x14},
	{0x1300, 0x03},
	{0x1301, 0x10},
	{0x1302, 0x22},
	{0x1303, 0x20},
	{0x1304, 0xe0},
	{0x1305, 0x21},
	{0x1306, 0x05},


	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0007, 0x80},
	{0x000d, 0x30},
	{0x0009, 0x00},
	{0x00c4, 0x10},
	{0x00c0, 0x01},
};

static struct regval_list  xc7021_480p_regs_15fps[] = {
    {0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0032, 0x09},
	{0x0025, 0x00},

	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x00bc, 0x11},
	{0x001b, 0x0},
	{0x0090, 0x29},

	{0xfffe, 0x20},
	{0x0000, 0x20},
	{0x0004, 0x7},
	{0x0005, 0x80},
	{0x0006, 0x4},
	{0x0007, 0x38},

	{0xfffe, 0x26},
	{0x4000, 0xF9},
	{0x6001, 0x14},
	{0x6005, 0xc4},
	{0x6006, 0x5},
	{0x6007, 0x78},
	{0x6008, 0x4},
	{0x6009, 0xFC},

	{0x8000, 0x3f},
	{0x8001, 0x80},
	{0x8002, 0x7},
	{0x8003, 0x38},
	{0x8004, 0x4},
	{0x8005, 0x3},
	{0x8006, 0x5},
	{0x8007, 0x99},
	{0x8008, 0x14},

	{0x8010, 0x4},
	{0x8012, 0x80},
	{0x8013, 0x7},
	{0x8014, 0x38},
	{0x8015, 0x4},
	{0x8016, 0x0},
	{0x8017, 0x0},
	{0x8018, 0x0},
	{0x8019, 0x0},

	{0xfffe, 0x30},
	{0x0001, 0x19},
	{0x0004, 0x18},
	{0x0006, 0x7},
	{0x0007, 0x80},
	{0x0008, 0x4},
	{0x0009, 0x38},
	{0x000a, 0x2},
	{0x000b, 0x80},
	{0x000c, 0x1},
	{0x000d, 0xE0},
	{0x0027, 0xF1},
	{0x005e, 0x7},
	{0x005f, 0x7F},
	{0x0060, 0x4},
	{0x0061, 0x37},
	{0x1908, 0x1},
	{0x1900, 0x0},
	{0x1901, 0xF0},
	{0x1902, 0x0},
	{0x1903, 0x0},
	{0x1904, 0x5},
	{0x1905, 0xA0},
	{0x1906, 0x4},
	{0x1907, 0x3A},

	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0004, 0x00},
	{0xfffd, 0x80},
	{0xfffe, 0x14},
	{0x1300, 0x03},
	{0x1301, 0x10},
	{0x1302, 0x22},
	{0x1303, 0x20},
	{0x1304, 0xe0},
	{0x1305, 0x21},
	{0x1306, 0x05},


	{0xfffd, 0x80},
	{0xfffe, 0x50},
	{0x0007, 0x80},
	{0x000d, 0x30},
	{0x0009, 0x00},
	{0x00c4, 0x10},
	{0x00c0, 0x01},
};

static struct regval_list f22dvp_default_regs[] = { /*f22_1920X1080_SET */
	/* f22_1920X1080_SET */
	{0x12, 0x40},
    {0x0E, 0x11},
    {0x0F, 0x00},
    {0x10, 0x36},
    {0x11, 0x80},
    {0x5F, 0x01},
    {0x60, 0x0A},
    {0x19, 0x20},
    {0x48, 0x05},
    {0x20, 0xB0},
    {0x21, 0x04},
    {0x22, 0x65},
    {0x23, 0x04},
    {0x24, 0xC0},
    {0x25, 0x38},
    {0x26, 0x43},
    {0x27, 0xC9},
    {0x28, 0x18},
    {0x29, 0x01},
    {0x2A, 0xC0},
    {0x2B, 0x21},
    {0x2C, 0x04},
    {0x2D, 0x01},
    {0x2E, 0x15},
    {0x2F, 0x44},
    {0x41, 0xCC},
    {0x42, 0x03},
    {0x39, 0x90},
    {0x1D, 0xFF},
    {0x1E, 0x1F},
    {0x6C, 0x90},
    {0x30, 0x8C},
    {0x31, 0x0C},
    {0x32, 0xF0},
    {0x33, 0x0C},
    {0x34, 0x1F},
    {0x35, 0xE3},
    {0x36, 0x0E},
    {0x37, 0x34},
    {0x38, 0x13},
    {0x3A, 0x08},
    {0x3B, 0x30},
    {0x3C, 0xC0},
    {0x3D, 0x00},
    {0x3E, 0x00},
    {0x3F, 0x00},
    {0x40, 0x00},
    {0x6F, 0x03},
    {0x0D, 0x10},
    {0x56, 0x32},
    {0x5A, 0x20},
    {0x5B, 0xB3},
    {0x5C, 0xF7},
    {0x5D, 0xF0},
    {0x62, 0x80},
    {0x63, 0x80},
    {0x64, 0x00},
    {0x67, 0x75},
    {0x68, 0x04},
    {0x6A, 0x4D},
    {0x8F, 0x18},
    {0x91, 0x04},
    {0x0C, 0x00},
    {0x59, 0x97},
    {0x4A, 0x05},
    {0x49, 0x10},
    {0x50, 0x02},
    {0x47, 0x22},
    {0x7E, 0xCD},
    {0x7F, 0x52},
    {0x7B, 0x57},
    {0x7C, 0x28},
    {0x80, 0x00},
    {0x13, 0x81},
    {0x12, 0x00},
    {0x93, 0x5C},
    {0x45, 0x89},
    /*{REG_DLY, 0x1F4},*/
    {0x45, 0x09},
    {0x1F, 0x01},
};

/*
 * Here we'll try to encapsulate the changes for just the output
 * video format.
 */

static struct regval_list sensor_fmt_yuv422_yuyv[] = {

};


static int sensor_write_f22(struct v4l2_subdev *sd, unsigned char reg,
    unsigned char value)
{
	int ret = 0;
	int cnt = 0;
	int addr;
	struct cci_driver *cci_drv = v4l2_get_subdevdata(sd);

	addr = cci_drv->cci_saddr;
	cci_drv->cci_saddr = I2C_ADDR_f22_SENSOR;

	ret = cci_write_a8_d8(sd, reg, value);
	while (ret != 0 && cnt < 2) {
		ret = cci_write_a8_d8(sd, reg, value);
		cnt++;
	}
	if (cnt > 0)
		sensor_dbg("sensor write retry=%d\n", cnt);
	cci_drv->cci_saddr = addr;
	return ret;
}


static int sensor_write_array_f22(struct v4l2_subdev *sd, struct regval_list *regs, int array_size)
{
	int ret = 0;
	int i = 0;
	struct cci_driver *cci_drv = v4l2_get_subdevdata(sd);

	if (!regs)
		return -EINVAL;
	f22_i2c_bypass(sd, 1);

	while (i < array_size) {
		if (regs->addr == REG_DLY) {  /*fix me????*/
			msleep(regs->data);
		} else {
			ret = sensor_write_f22(sd, regs->addr, regs->data);
			if (ret < 0)
				printk("%s sensor write array error!!\n", cci_drv->name);
		}
		i++;
		regs++;
	}

	f22_i2c_bypass(sd, 0);
	return 0;
}

static int sensor_read_f22(struct v4l2_subdev *sd, unsigned char reg,
    unsigned char *value)
{
	int ret = -1;
	int cnt = 0;
	struct cci_driver *cci_drv = v4l2_get_subdevdata(sd);
	int addr =  cci_drv->cci_saddr;

	cci_drv->cci_saddr = I2C_ADDR_f22_SENSOR;
	ret = cci_read_a8_d8(sd, reg, value);
	while (ret != 0 && cnt < 8) {
		ret = cci_read_a8_d8(sd, reg, value);
		cnt++;
	}
	cci_drv->cci_saddr = addr;
	if (cnt > 0)
		sensor_dbg("sensor read retry=%d\n", cnt);

	return ret;

}

static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
{
	struct sensor_info *info = to_state(sd);

	*value = info->exp;
	sensor_dbg("sensor_get_exposure = %d\n", info->exp);

	return 0;
}

/*
static int sensor_s_exp(struct v4l2_subdev *sd, unsigned int exp_val)
{
	struct sensor_info *info = to_state(sd);

	info->exp = exp_val;
	return 0;
}
*/

static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
{
	struct sensor_info *info = to_state(sd);

	*value = info->gain;
	sensor_dbg("sensor_get_gain = %d\n", info->gain);
	return 0;
}

/*
static int sensor_s_gain(struct v4l2_subdev *sd, int gain_val)
{
	struct sensor_info *info = to_state(sd);

	info->gain = gain_val;

	return 0;

}
*/

static int sensor_s_exp_gain(struct v4l2_subdev *sd,
			     struct sensor_exp_gain *exp_gain)
{
	int exp_val, gain_val;
	struct sensor_info *info = to_state(sd);

	exp_val = exp_gain->exp_val;
	gain_val = exp_gain->gain_val;

	info->exp = exp_val;
	info->gain = gain_val;
	return 0;
}

static int sensor_s_sw_stby(struct v4l2_subdev *sd, int on_off)
{
	int ret = 0;
	return ret;
}

/*
 * Stuff that knows about the sensor.
 */

static int sensor_power(struct v4l2_subdev *sd, int on)
{
	int ret;
	ret = 0;
	switch (on) {
	case STBY_ON:
		sensor_dbg("CSI_SUBDEV_STBY_ON!\n");
		cci_lock(sd);
		vin_gpio_write(sd, PWDN, CSI_GPIO_HIGH);
		vin_set_mclk(sd, OFF);
		cci_unlock(sd);
		break;
	case STBY_OFF:
		sensor_dbg("CSI_SUBDEV_STBY_OFF!\n");
		cci_lock(sd);
		vin_set_mclk_freq(sd, MCLK);
		vin_set_mclk(sd, ON);
		usleep_range(10000, 12000);
		vin_gpio_write(sd, PWDN, CSI_GPIO_LOW);
		usleep_range(10000, 12000);
		cci_unlock(sd);
		ret = sensor_s_sw_stby(sd, CSI_GPIO_LOW);
		if (ret < 0)
			sensor_err("soft stby off falied!\n");
		usleep_range(10000, 12000);
		break;
	case PWR_ON:
		sensor_dbg("CSI_SUBDEV_PWR_ON!\n");
		cci_lock(sd);
		vin_gpio_set_status(sd, PWDN, 1);	/*set the gpio to output */
		vin_gpio_set_status(sd, RESET, 1);	/*set the gpio to output */

		vin_gpio_write(sd, RESET, CSI_GPIO_HIGH);
		vin_gpio_write(sd, PWDN, CSI_GPIO_HIGH);
		usleep_range(1000, 1200);
		vin_gpio_write(sd, POWER_EN, CSI_GPIO_HIGH);
		vin_set_pmu_channel(sd, AFVDD, ON);	/*1.2V  CVDD_12 */
		vin_set_pmu_channel(sd, DVDD, ON);	/*xc7021 VCAM_D 1.2v */
		usleep_range(1000, 1200);
		vin_set_pmu_channel(sd, IOVDD, ON);	/*VCAM_IO 3.3v */

		usleep_range(1000, 1200);
		vin_set_pmu_channel(sd, AVDD, ON);	/* VCAM_AF 1.2v */
		usleep_range(1000, 1200);

		vin_gpio_write(sd, PWDN, CSI_GPIO_LOW);
		usleep_range(10000, 12000);
		vin_gpio_write(sd, RESET, CSI_GPIO_LOW);
		usleep_range(30000, 32000);
		vin_gpio_write(sd, RESET, CSI_GPIO_HIGH);
		vin_set_mclk_freq(sd, MCLK);
		vin_set_mclk(sd, ON);
		usleep_range(10000, 12000);
		cci_unlock(sd);
		break;

	case PWR_OFF:
		sensor_dbg("CSI_SUBDEV_PWR_OFF!\n");
		cci_lock(sd);
		vin_gpio_write(sd, POWER_EN, CSI_GPIO_LOW);
		vin_gpio_set_status(sd, PWDN, 1);	/*set the gpio to output */
		vin_gpio_set_status(sd, RESET, 1);	/*set the gpio to output */
		vin_gpio_write(sd, RESET, CSI_GPIO_LOW);
		vin_gpio_write(sd, PWDN, CSI_GPIO_HIGH);
		vin_set_mclk(sd, OFF);
		vin_set_pmu_channel(sd, AVDD, OFF);	/* VCAM_AF 3.3v */
		usleep_range(10000, 12000);
		vin_set_pmu_channel(sd, DVDD, OFF);	/*VCAM_D 1.5v */
		usleep_range(10000, 12000);
		vin_set_pmu_channel(sd, IOVDD, OFF);	/*VCAM_IO 2.8v */
		vin_set_pmu_channel(sd, AFVDD, OFF);	/*1.2V  CVDD_12 */
		vin_gpio_set_status(sd, RESET, 0);	/*set the gpio to input */
		vin_gpio_set_status(sd, PWDN, 0);	/*set the gpio to input */
		cci_unlock(sd);
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

static int sensor_reset(struct v4l2_subdev *sd, u32 val)
{
	switch (val) {
	case 0:
		vin_gpio_write(sd, RESET, CSI_GPIO_HIGH);
		usleep_range(10000, 12000);
		break;
	case 1:
		vin_gpio_write(sd, RESET, CSI_GPIO_LOW);
		usleep_range(10000, 12000);
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

static int xc7021_isp_detect(struct v4l2_subdev *sd)
{
	int ret;
	struct regval_list regs;

	regs.addr = 0xfffb;
	ret = sensor_read(sd, regs.addr, &regs.data);
	sensor_dbg("f22_xc7021 [0xfffb] chip  ID =0x%x\n ", regs.data);

	regs.addr = 0xfffc;
	ret = sensor_read(sd, regs.addr, &regs.data);
	if (ret < 0) {
		sensor_err("sensor_read err at sensor_detect!\n");
		return ret;
	}
	sensor_dbg("f22_xc7021 [0xfffc] chip  ID =0x%x\n ", regs.data);

	return 0;
}

static int f22_i2c_bypass(struct v4l2_subdev *sd, bool enable)
{
	int ret = -1;
	if (enable > 0) {
		ret = sensor_write_array(sd, bypass_on, ARRAY_SIZE(bypass_on));
		printk("f22_i2c_bypass bypass_on\n");
	} else {
		ret = sensor_write_array(sd, bypass_off, ARRAY_SIZE(bypass_off));
		printk("f22_i2c_bypass bypass_off\n");
	}
	if (ret < 0) {
		sensor_err("write  i2c_bypass %d sensor_default_regs fail \n", enable);
		return ret;
	}

	return 0;
}

static int sensor_detect(struct v4l2_subdev *sd)
{
	int ret;
	struct regval_list regs;

	f22_i2c_bypass(sd, 1);
	regs.addr = 0x0a;
	regs.data = f22_CHIPID;

	ret = sensor_read_f22(sd, regs.addr, (unsigned char *)&regs.data);
	sensor_dbg("f22 chip  ID [0x0a]=0x%x\n ", regs.data);
	printk("f22_xc7021 chip  ID [0x0a]=0x%x\n ", regs.data);
	if (ret < 0 || (regs.data != f22_CHIPID)) {
		sensor_err("sensor_read err at sensor_detect!\n");
		ret = -1;
	}

	ret = sensor_read_f22(sd, 0x0b , (unsigned char *)&regs.data);
	if (ret < 0 || (regs.data != 0x22)) {
		sensor_err("sensor_read err at sensor_detect!\n");
		ret = -1;
	}
	sensor_dbg("f22_xc7021 chip  ID [0x0b]=0x%x\n ", regs.data);
	printk("f22_xc7021 chip  ID [0x0b]=0x%x\n ", regs.data);
	f22_i2c_bypass(sd, 0);

	return ret;
}

static int sensor_init(struct v4l2_subdev *sd, u32 val)
{
	int ret;
	struct sensor_info *info = to_state(sd);

	sensor_dbg("sensor_init\n");
	/*Make sure it is a target sensor */
	ret = xc7021_isp_detect(sd);
	if (ret) {
		sensor_err("xc7021_isp chip is not an target chip.\n");
		return ret;
	} else
		sensor_print("xc7021_isp chip found is target chip.\n");

	info->focus_status = 0;
	info->low_speed = 0;
	info->width = HD1080_WIDTH;
	info->height = HD1080_HEIGHT;
	info->hflip = 0;
	info->vflip = 0;
	info->gain = 0;

	info->tpf.numerator = 1;
	info->tpf.denominator = SENSOR_FRAME_RATE;

	ret = sensor_write_array(sd, XC7021_default_regs,
			ARRAY_SIZE(XC7021_default_regs));
	if (ret < 0) {
		sensor_err("write sensor_default_regs error\n");
		return ret;
	}
	msleep(10);

	ret = sensor_detect(sd);
	if (ret) {
		sensor_err("chip found is not an target chip.\n");
		return ret;
	}

	return 0;
}

static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
{
	int ret = 0;
	struct sensor_info *info = to_state(sd);
	switch (cmd) {
	case GET_CURRENT_WIN_CFG:
		if (info->current_wins != NULL) {
			memcpy(arg, info->current_wins,
			       sizeof(struct sensor_win_size));
			ret = 0;
		} else {
			sensor_err("empty wins!\n");
			ret = -1;
		}
		break;
	case SET_FPS:
		break;
	case ISP_SET_EXP_GAIN:
		sensor_s_exp_gain(sd, (struct sensor_exp_gain *)arg);
		break;
	default:
		return -EINVAL;
	}

	return ret;
}

static struct sensor_format_struct  sensor_formats[] = {
	{
		.desc		= "YUYV 4:2:2",
		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,
		.regs 		= sensor_fmt_yuv422_yuyv,
		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
		.bpp		= 2,
	},
};
#define N_FMTS ARRAY_SIZE(sensor_formats)

/*
 * Then there is the issue of window sizes.  Try to capture the info here.
 */
static struct sensor_win_size sensor_win_sizes_30fps[] = {
	{
	 .width = HD1080_WIDTH,
	 .height = HD1080_HEIGHT,
	 .hoffset = 0,
	 .voffset = 0,
	 .regs = xc7021_1080p_regs_30fps,
	 .regs_size = ARRAY_SIZE(xc7021_1080p_regs_30fps),
	 .set_size = NULL,
	 },
	 {
     .width = HD720_WIDTH,
     .height = HD720_HEIGHT,
     .hoffset = 0,
     .voffset = 0,
     .regs = xc7021_720p_regs_30fps,
     .regs_size = ARRAY_SIZE(xc7021_720p_regs_30fps),
     .set_size = NULL,
	 },
	 {
	.width = VGA_WIDTH,
	.height = VGA_HEIGHT,
	.hoffset = 0,
	.voffset = 0,
	.regs = xc7021_480p_regs_30fps,
	.regs_size = ARRAY_SIZE(xc7021_480p_regs_30fps),
	.set_size = NULL,
	},
	/*
	{
	.width = VGA_WIDTH,
	.height = 360,
	.hoffset = 0,
	.voffset = 0,
	.regs = xc7021_360p_regs_25fps,
	.regs_size = ARRAY_SIZE(xc7021_360p_regs_25fps),
	.set_size = NULL,
	},*/
};

static struct sensor_win_size sensor_win_sizes_15fps[] = {
	{
	 .width = HD1080_WIDTH,
	 .height = HD1080_HEIGHT,
	 .hoffset = 0,
	 .voffset = 0,
	 .regs = xc7021_1080p_regs_15fps,
	 .regs_size = ARRAY_SIZE(xc7021_1080p_regs_15fps),
	 .set_size = NULL,
	 },
	 {
     .width = HD720_WIDTH,
     .height = HD720_HEIGHT,
     .hoffset = 0,
     .voffset = 0,
     .regs = xc7021_720p_regs_15fps,
     .regs_size = ARRAY_SIZE(xc7021_720p_regs_15fps),
     .set_size = NULL,
	 },
	 {
	.width = VGA_WIDTH,
	.height = VGA_HEIGHT,
	.hoffset = 0,
	.voffset = 0,
	.regs = xc7021_480p_regs_15fps,
	.regs_size = ARRAY_SIZE(xc7021_480p_regs_15fps),
	.set_size = NULL,
	},
	/*
	{
	.width = VGA_WIDTH,
	.height = 360,
	.hoffset = 0,
	.voffset = 0,
	.regs = xc7021_360p_regs_15fps,
	.regs_size = ARRAY_SIZE(xc7021_360p_regs_15fps),
	.set_size = NULL,
	},*/
};

#define N_WIN_SIZES_15FPS (ARRAY_SIZE(sensor_win_sizes_15fps))
#define N_WIN_SIZES_30FPS (ARRAY_SIZE(sensor_win_sizes_30fps))

static int sensor_g_mbus_config(struct v4l2_subdev *sd,
				struct v4l2_mbus_config *cfg)
{
	cfg->type = V4L2_MBUS_PARALLEL;
	cfg->flags = V4L2_MBUS_MASTER | VREF_POL | HREF_POL | CLK_POL;

	return 0;
}

static int sensor_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
{
	/* Fill in min, max, step and default value for these controls. */
	/* see include/linux/videodev2.h for details */

	switch (qc->id) {
	case V4L2_CID_GAIN:
		return v4l2_ctrl_query_fill(qc, 1 * 16, 16 * 16, 1, 16);
	case V4L2_CID_EXPOSURE:
		return v4l2_ctrl_query_fill(qc, 1, 65536 * 16, 1, 1);
	case V4L2_CID_FRAME_RATE:
		return v4l2_ctrl_query_fill(qc, 15, 120, 1, 30);
	}
	return -EINVAL;
}

static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
	switch (ctrl->id) {
	case V4L2_CID_GAIN:
		return sensor_g_gain(sd, &ctrl->value);
	case V4L2_CID_EXPOSURE:
		return sensor_g_exp(sd, &ctrl->value);
	}
	return -EINVAL;
}

static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
#if 0
	struct v4l2_queryctrl qc;
	int ret;

	qc.id = ctrl->id;
	ret = sensor_queryctrl(sd, &qc);
	if (ret < 0) {
		return ret;
	}

	if (ctrl->value < qc.minimum || ctrl->value > qc.maximum) {
		sensor_err("max gain qurery is %d,min gain qurey is %d\n",
			    qc.maximum, qc.minimum);
		return -ERANGE;
	}

	switch (ctrl->id) {
	case V4L2_CID_GAIN:
		return sensor_s_gain(sd, ctrl->value);
	case V4L2_CID_EXPOSURE:
		return sensor_s_exp(sd, ctrl->value);
	}
	return -EINVAL;
#else
	return 0;
#endif
}

static int sensor_g_chip_ident(struct v4l2_subdev *sd,
			       struct v4l2_dbg_chip_ident *chip)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);

	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
}

static int sensor_reg_init(struct sensor_info *info)
{
	struct v4l2_subdev *sd = &info->sd;
	struct sensor_format_struct *sensor_fmt = info->fmt;
	struct sensor_win_size *wsize = info->current_wins;
	int ret;
	struct regval_list regs;

	sensor_dbg("sensor_reg_init\n");
	sensor_write_array(sd, sensor_fmt->regs, sensor_fmt->regs_size);

	if (wsize->regs)
		sensor_write_array(sd, wsize->regs, wsize->regs_size);
	msleep(10);

#ifndef DEBUG_COLORBAR
	sensor_detect(sd);
	/*f22 initial*/
	sensor_write_array_f22(sd, f22dvp_default_regs, ARRAY_SIZE(f22dvp_default_regs));
#endif
	msleep(10);
	f22_i2c_bypass(sd, 1);
	sensor_write_f22(sd, 0x0e, 0x11);
	msleep(5);
	ret = sensor_read_f22(sd, 0x0e, (unsigned char *)&regs.data);
	printk("f22_xc7021 [0x0e]=0x%x\n ", regs.data);
	ret = sensor_read_f22(sd, 0x0f, (unsigned char *)&regs.data);
	printk("f22_xc7021 [0x0f]=0x%x\n ", regs.data);
	ret = sensor_read_f22(sd, 0x10, (unsigned char *)&regs.data);
	printk("f22_xc7021 [0x10]=0x%x\n ", regs.data);
	ret = sensor_read_f22(sd, 0x11, (unsigned char *)&regs.data);
	printk("f22_xc7021 [0x11]=0x%x\n ", regs.data);
	ret = sensor_read_f22(sd, 0x49, (unsigned char *)&regs.data);
	printk("f22_xc7021 [0x49]=0x%x\n ", regs.data);
	f22_i2c_bypass(sd, 0);

	return 0;
}

static int sensor_s_stream(struct v4l2_subdev *sd, int enable)
{
	struct sensor_info *info = to_state(sd);
	sensor_print("%s on = %d, %d*%d %x\n", __func__, enable,
		  info->current_wins->width,
		  info->current_wins->height, info->fmt->mbus_code);

	if (!enable)
		return 0;
	return sensor_reg_init(info);
}


/* ----------------------------------------------------------------------- */

static const struct v4l2_subdev_core_ops sensor_core_ops = {
	.g_chip_ident = sensor_g_chip_ident,
	.g_ctrl = sensor_g_ctrl,
	.s_ctrl = sensor_s_ctrl,
	.queryctrl = sensor_queryctrl,
	.reset = sensor_reset,
	.init = sensor_init,
	.s_power = sensor_power,
	.ioctl = sensor_ioctl,
};

static const struct v4l2_subdev_video_ops sensor_video_ops = {
	.s_parm = sensor_s_parm,
	.g_parm = sensor_g_parm,
	.s_stream = sensor_s_stream,
	.g_mbus_config = sensor_g_mbus_config,
};

static const struct v4l2_subdev_pad_ops sensor_pad_ops = {
	.enum_mbus_code = sensor_enum_mbus_code,
	.enum_frame_size = sensor_enum_frame_size,
	.get_fmt = sensor_get_fmt,
	.set_fmt = sensor_set_fmt,
};

static const struct v4l2_subdev_ops sensor_ops = {
	.core = &sensor_core_ops,
	.video = &sensor_video_ops,
	.pad = &sensor_pad_ops,
};

/* ----------------------------------------------------------- */
static struct cci_driver cci_drv = {
	.name = SENSOR_NAME,
	.addr_width = CCI_BITS_16,
	.data_width = CCI_BITS_8,
};

static int sensor_probe(struct i2c_client *client,
			const struct i2c_device_id *id)
{
	struct v4l2_subdev *sd;
	struct sensor_info *info;
	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);

	if (info == NULL)
		return -ENOMEM;
	sd = &info->sd;
	cci_dev_probe_helper(sd, client, &sensor_ops, &cci_drv);
	mutex_init(&info->lock);
	info->fmt = &sensor_formats[0];
	info->fmt_pt = &sensor_formats[0];

	if (info->tpf.denominator == SENSOR_FRAME_RATE_15FPS) {
		info->win_pt = &sensor_win_sizes_15fps[0];
		info->win_size_num = N_WIN_SIZES_15FPS;
	} else {
		info->win_pt = &sensor_win_sizes_30fps[0];
		info->win_size_num = N_WIN_SIZES_30FPS;
	}

	info->fmt_num = N_FMTS;

	info->sensor_field = V4L2_FIELD_NONE;
	info->af_first_flag = 1;
	return 0;
}

static int sensor_remove(struct i2c_client *client)
{
	struct v4l2_subdev *sd;
	sd = cci_dev_remove_helper(client, &cci_drv);
	kfree(to_state(sd));
	return 0;
}

static const struct i2c_device_id sensor_id[] = {
	{SENSOR_NAME, 0},
	{}
};

MODULE_DEVICE_TABLE(i2c, sensor_id);

static struct i2c_driver sensor_driver = {
	.driver = {
		   .owner = THIS_MODULE,
		   .name = SENSOR_NAME,
		   },
	.probe = sensor_probe,
	.remove = sensor_remove,
	.id_table = sensor_id,
};

static __init int init_sensor(void)
{
	return cci_dev_init_helper(&sensor_driver);
}

static __exit void exit_sensor(void)
{
	cci_dev_exit_helper(&sensor_driver);
}

module_init(init_sensor);
module_exit(exit_sensor);
